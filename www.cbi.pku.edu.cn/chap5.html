<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=gb_2312-80">
<meta name="GENERATOR" content="Microsoft FrontPage Express 2.0">
<title>Emacs 的基本编辑指令</title>
</head>

<body>

<h1>Emacs 的基本编辑指令</h1>

<h4>前面的四个章节已经把 EMACS
的环境与架构做了扼要的介绍， 现在开始讨论
EMACS 做为编辑器（editor）所能 提供的服务。 </h4>

<h2><a name="1">如何载入档案与储存档案</a></h2>

<h4>使用编辑器最基本的需求，就是要能载入档案以便编辑。
现在就先来看看 EMACS 是如何处理档案的载入。
EMACS 载入档案的方法很简单，只要在键入
&quot;Ctrl-x Ctrl-f&quot; 之後，再利用 <i>minibuffer</i>
输入所要编辑的档名即可。 档名的输入可以与 <i>completion</i>
相互搭配。 键入 ``Ctrl-x Ctrl-f'' 命令之後，在 <i>mininbuffer</i>
处输入 已存在硬碟的档案， EMACS 会执行如下的过程：
</h4>

<ol>
    <li>产生一个新的缓冲区。</li>
    <li>将所欲编辑档案的内容，拷贝至缓冲区内。</li>
    <li>将缓冲区的内容显示出来，以便编辑。</li>
</ol>

<pre>这整个事件的过程，在 EMACS 的编辑系统中称为「访问档案」
（<i> visiting file </i>）。
虽然载入档案的方法很简单，但仍有几件事情值得讨论的，
现说明如下：
</pre>

<ul>
    <li>键入 ``Ctrl-x Ctrl-f'' 後， <i>echo area</i>
        会显示目前缓冲区 的目录，此时若编辑档案的目录与
        <i>echo area</i> 所显示的目录 相同，可迳在其後输入档名即可。</li>
    <li>若档案所在的目录与目前缓冲区的目录不同，输入档名的方法
        有如下几种：</li>
    <li><ul>
            <li>档案在同一个机器上的做法：</li>
            <li><ul>
                    <li>无视 <i>echo area</i>
                        所显示的目录，由使用者重新输入档名。</li>
                    <li>键入新档名的方法，是在 <i>echo
                        area</i> 显示目录的最後方键入
                        ``/'' ,``/'' 代表， 忽略``/''
                        之前面的路径，新的路径从 ``的路径
                        必须键入绝对路径（absolute file
                        name）。 现举一实例说明。 Find
                        file: ~/work/emacs/emacs.tex
                        所要编辑的档案在
                        ~/work/doc/text.tex
                        此时输入正确档名的做法如下所示：
                        Find
                        file:~/work/emacs/emacs.tex//~/work/doc/text.tex
                    </li>
                    <li>以 EMACS
                        提供的删除功能，将不必要的字删除之後，</li>
                    <li>再输入正确的资料.
                        除非显示的目录与所欲编辑的目录相差无几，使用删除的方法
                        才有意义，否则不如放弃所显示目录，重新开始新的生涯才是正途。
                        至於如何删字，会在 5.2.5
                        一节中说明，此处就不赘言。 </li>
                </ul>
                <p>所欲编辑的档案，不在目前所在的机器上的做法，如下所示：
                前已述及 EMACS 可以 FTP
                的方式来编辑远方的档案，但 EMACS
                是如何以 FTP 的方法来编辑远方　档案呢？想要编辑远方的档案，
                只要给予正确的语法， EMACS 就会根据其语法来决定是否要使用
                FTP 来编辑此档案了。其语法很简单，只有
                /host:filename 而已。 如何来使用其语法呢？
                由其语法可知，其语法是由四组元素所组成的字串，包括二组子字串
                （host 和 filename）以及二个符号（/ 和
                :）。在 <i>minibuffer</i> 处 输入 /
                後，紧接给予档案所在的机器名称（host），在其後立即给予
                ``:'' ，在 ``:'' 後则输入所欲编辑档案，整个访问档案的过程就完成。
                注意此四组资料间，不可以留有任何的的空白。现举一实例子来说明之。
                Find
                file:~/work/emacs.tex//hsko@gate.sinica.edu.tw:~/work/text.tex
                </p>
            </li>
            <li>键入 ``Ctrl-x Ctrl-f'' 当 <i>echo area</i>
                显示出目前缓冲区</li>
            <li>的目录後，只给予 RET
                而别无它物时， EMACS 以目前缓冲区
                所使用的档案为预设档案。 </li>
            <li>键入 ``Ctrl-x Ctrl-f''
                後，突然改变心意，想知此目录以外
                其它目录的档名，除了使用 ``Ctrl-x d''（使用目录的编辑指令－dired）
                指令外，还可以利用现有的目录名称来得到想要的讯息。其作法
                是直接修改 <i>echo area</i> 所显示的目录，直到所要的目录
                出现後，键入 RET，此时会另开启一个视窗来显示出此目录下
                的所有档名。若想操作这些档案，其操作方式与运作
                Dired 的 方式相同。若对 Dired
                的印象已经模　的人，请参阅 3.2 节
                。 </li>
        </ul>
        <dl>
            <dd>以上是介绍档名的输入方式。在编辑资料的同时，是否
                可以轻易查得目前所在的目录？&quot;
                Meta-x pwd&quot; 指令可以满足
                这种需求。键入 &quot; Meta-x pwd&quot;
                後， EMACS 会假借 <i>echo area</i>将目前所在的目录显示出来。
            </dd>
            <dd>以上谈的都是 EMACS
                输入档案的方式，但 EMACS 又是如何为其缓冲区命名的呢？其实使用者并不需要为缓冲区命名，
                因为 EMACS 会自动给予缓冲区合适的名称。EMACS
                为缓冲区的 命名，可以从 <i>mode line</i>上得知。
            </dd>
            <dd>EMACS
                命名缓冲区的方式是根据所键入的档案名称而来，
                它舍弃了所有的目录名称只保留编辑档案的档名。所以若全名为
                ``/user/work/emacs.tex''
                的档案，其缓冲区的名称则为
                ``emacs.tex'' 。
                除了将档案从硬碟直接载入缓冲区外，在编辑档案的同时，
                有时需要参考其它的档案，甚至需要引进其它的档案到目前所使用
                的缓冲区内。 EMACS 的 `` Ctrl-x i''
                指令，就是让使用者能随时
                引进其它的档案到目前的缓冲区内。
                ``Ctrl-x i'' 的 `` i'' 是 insert
                的意思，相信了解意思後，对於该指令应有较深刻的印象，否则
                怎有知已知彼，百战百胜之说呢？
                以下是 EMACS 有关档案载入指令的整理：
                <ul>
                    <li>Ctrl-x Ctrl-f（find-file）</li>
                    <li>Ctrl-x i（insert-file） </li>
                    <li>Meta-x pwd </li>
                </ul>
                <p>文件编辑完後，最重要的事情就是要能将其保留下来。以下就
                来谈谈文件储存的方法。档案储存不外乎将缓冲区的内容以原名
                或易名存回磁碟；此储存方式可以选择一次存一个档案或一次
                存数个档案；最後的考量是存完档案後是否要直接离开
                EMACS。 下面就来看看EMACS
                所提供的相关指令。 </p>
                <ul>
                    <li>存档但不离开 EMACS </li>
                    <li><ul>
                            <li>Ctrl-x Ctrl-s（save-buffer</li>
                            <li>将目前缓冲区的内容，存回磁碟中。存回的档案名称与缓冲区
                                的名称相同
                                。此指令只对目前所使用的缓冲区做存档的动作。若缓冲区
                                的内容未有任何的变动则
                                <i>echo area</i>
                                会显示如下的文字： （No
                                changes need to be saved） </li>
                            <li>Ctrl-x Ctrl-w（write-file）</li>
                            <li>此指令与上一个指令相似，不同之处在於可以使用与缓冲区
                                不同的档案名称存档。。换言之，可另行指定存回磁碟的档名。
                                键入 ``Ctrl-x Ctrl-w'' 後， <i>echo
                                area</i> 会显示出目前
                                缓冲区所在的目录，
                                此时，使用者可根据需要输入档名。若不输入任何档名只键入
                                RET ， 系统仍会将缓冲区内的资料存回原先访问的档案中。此指令
                                也只对目前所使用的缓冲区做存档的动作。</li>
                            <li>Ctrl-x s（save-some-buffers）</li>
                            <li>此指令可用来储存所有被修改过的缓冲区。使用此指令时，
                                <i>echo area</i> 除了显示
                                档案名称外，还会在档名之後出现
                                （y, n, !, ., q, C-r or C-h）
                                这些讯息是提供给使用者做参考的。现在就告诉使用者这些
                                讯息所代表的意义。 <ol>
                                    <li>y</li>
                                    <li>同意对 <i>echo area</i>
                                        所显示的缓冲区存档，进一步
                                        徵询其它档案是否存档的意见。
                                    </li>
                                    <li>n</li>
                                    <li>放弃对 <i>echo area</i>
                                        所显示的缓冲区存档，但徵询
                                        其它档案是否
                                        存档的意见。 </li>
                                    <li>!</li>
                                    <li>同意对 <i>echo area</i>
                                        所显示的缓冲区存档且一并
                                        对其它的缓冲区存档，此时不再一一徵询其它档案是否
                                        存档的意见。</li>
                                    <li>.</li>
                                    <li>同意对 <i>echo area</i>
                                        所显示的缓冲区存档，但放弃
                                        对其它未存档的缓冲区存档，且直接离开此存档的状态。
                                    </li>
                                    <li>q</li>
                                    <li>离开存档的状态而不执行任何存档的动作。
                                    </li>
                                    <li>C-r </li>
                                    <li>可以此指令流　目前所要储存的档案内容，当离开此流　
                                        状态即回复存档的模式，系统会再度询问与存档有关的讯息。
                                    </li>
                                    <li>C-h</li>
                                    <li>对於以上的选项若有不明白的地方，可以此功能查阅其意思。
                                    </li>
                                </ol>
                            </li>
                        </ul>
                    </li>
                    <li>存档後直接离开 EMACS </li>
                    <li>Ctrl-x Ctrl-c（save-buffers-kill-emacs）
                        此指令容许用者在决定是否将缓冲区的内容存档後，立即
                        离开 EMACS。此指令实际上是先执行
                        ``save-some-buufers'' 的动作再离开
                        EMACS。 </li>
                </ul>
                <p>讨论完了载入与储存档案的功能之後，相信已经迫不急待想要
                知道如何编辑一份心目中想要的文件。现在就是介绍如何编辑
                档案的时候了。 </p>
                <hr>
                <h2><a name="2">Emacs 的基础编辑指令</a></h2>
                <h4>编辑器做些什麽事呢？现在先谈谈编辑器的基本功能，至於
                编辑器的进阶功能则在下一章讨论。此处所谈的基本或进阶的功能，
                所指的都是 EMACS 可以提供的功能，所区分的基本和进阶也只是
                为了讨论上的方便而已。 </h4>
            </dd>
            <dd>所谓的编辑器就是用来编辑文件的器具。一张纸与一支笔，
                就可以满足文件的编辑，这也是最简单且最原始的编辑器。
                将纸笔产生文件的动作以电脑来代步，就是电子编辑器
                （以下简称编辑器）主要的功能，也是本文所要讨论的编辑器。
            </dd>
            <dd>文件的编辑不外乎文件的键入、游标的移动、文件的搬移
                与删除以及文件资料的找寻与取代等等。现将
                EMACS 可提供
                的基本编辑功能简列如下，其详细的用法会在以下的各节中一一叙及。
                EMACS 所能提供的基本编辑功能如下： <ul>
                    <li>字元输入与显示在萤幕上的方式</li>
                    <li><ul>
                            <li>字元的显示方式，可使用插入法（insert）或覆盖（overwrite）的方法。</li>
                            <li>除了一般的字元（ASCII
                                Character）外，还可以显示特殊字元</li>
                            <li>（Special Character）以及任何八进位超过
                                200 的字元。 </li>
                            <li>文件在萤幕上所能显示的范围。</li>
                        </ul>
                    </li>
                    <li><i>point</i>（cursor）
                        的移动方式（move <i>point</i>）</li>
                    <li><ul>
                            <li><i>point</i>
                                能左右移动一个或数个字元（character）</li>
                            <li>　</li>
                            <li><i>point</i>
                                能左右移动一个或数个字（word）</li>
                            <li>　</li>
                            <li><i>point</i>
                                能移至一列的开头或结尾</li>
                            <li>　</li>
                            <li><i>point</i>
                                能上下移动一列或数列（line）</li>
                            <li>　</li>
                            <li><i>point</i>
                                的设定，使游标能上下移动至指定的栏位</li>
                            <li>　</li>
                            <li><i>point</i>
                                的移动能以页为单位（page）</li>
                            <li>　</li>
                            <li><i>point</i>
                                能至萤幕的前端或尾端</li>
                            <li>　</li>
                            <li><i>point</i>
                                能移至缓冲区的前端或尾端</li>
                            <li>　</li>
                        </ul>
                    </li>
                    <li>显示缓冲区大小与 <i>point</i>
                        所在的位置</li>
                    <li>删除萤幕上所显示的文件</li>
                    <li><ul>
                            <li>向左或向右删除一个字元（character）</li>
                            <li>　</li>
                            <li>向左或向右删除一个字（word）</li>
                            <li>　</li>
                            <li>删除游标所在位置以後的所有文件</li>
                            <li>　</li>
                            <li>删除一个区块的文件（region）</li>
                            <li>　</li>
                            <li>删除的文件可以再使用（yank）</li>
                            <li>　</li>
                        </ul>
                    </li>
                    <li>文件的搬移与拷贝（move and copy）</li>
                </ul>
            </dd>
            <dd>编辑器具备以上的功能，就可以编辑出想要的文件。
                现在就来看看如何在EMACS
                所提供的编辑环境，来编辑出 想要的文件。
                <hr>
                <h3><a>在 Emacs 中如何加入与显示文件</a>
                </h3>
                <h4>EMACS
                允许输入文件时，将资料直接输入在 <i>point</i>
                所在位置 的正前方，此方法称为
                insert mode；或将输入的资料以覆盖的
                方式取代 <i>point</i>
                所在位置的字元，此方法则称为
                overwrite mode。 现举一实例来说明 insert
                mode 与 overwrite mode 的异同。 </h4>
                <ul>
                    <li>字串 food， <i>point</i>
                        所在位置为 d 处，此时的状态为
                        insert mode。</li>
                    <li>在 <i>point</i> 所在的 d 处键入 t
                        ，原字串变为 footd。</li>
                    <li>字串 food， <i>point</i>
                        所在位置为 d 处，此时的状态为
                        overwrite mode。 在 <i>point</i>
                        所在的 d 处键入 t
                        ，原字串变为 foot。</li>
                </ul>
                <p>EMACS 对输入模式的预设值是 insert
                mode，若想将模式转换成 overwrite mode，
                指令 `` Meta-x overwrite-mode RET''
                可满足此一需求。若想恢复 insert mode，只需再使用一次
                `` Meta-x overwrite-mode RET''就可以了
                。当输入模式转为 overwrite mode
                时，萤幕下方的 mode line 会显示
                ``Ovwrt'' 的讯息，用以提示目前是使用
                overwrite 的模式。 指令 `` Meta-x
                overwrite-mode''是用来转换 insert mode 与
                overwrite mode </p>
                <p>。在此前提下，原为 insert mode
                ，经转换 则为 overwrite mode。反之，若原为
                overwrite mode 则转换成 insert mode。 </p>
            </dd>
            <dd>EMACS 的 overwrite mode
                只针对从键盘输入的文件有效，
                若文件不是从键盘输入，而是以别的方式产生的，则一律失去
                overwrite的效用。例如，拷贝而来的文件或以
                `` Ctrl-x i'' 得来的文件， EMACS
                一律使用insert mode。 </dd>
            <dd>除了 insert 与 overwrite 的显示方法外，
                EMACS 还允许 使用者输入一些从键盘上无法输入的字，那就是一些控制码
                和八进位超过 200 的字元。要输入这些特殊的文字时，只要在
                这些字的前方加上 `` Ctrl-q''即可。例如，要输入分页码
                （formfeed ，ASCII Ctrl-L， octal code 014），
                则输入 ``Ctrl-q Ctrl-l''
                即可。此时萤幕会出现 C此时萤幕会出现
                ^L 的符号。当输入文件的长度，超过
                EMACS 视窗宽度所能显示 的范围，EMACS
                对此情形的处理如下所示： <ul>
                    <li>若文件太长需要换列时，在换列处键入
                        RET ，其後的文字 会自动转到下一列且以第一个栏位为新列的起始点。若其後没有
                        文件而键入 RET
                        ，游标会会停在下一列的第一个栏位。</li>
                    <li>不理会文件是否会超过视窗的宽度，也就是不键入
                        RET 而 继续输入文字。 EMACS
                        会自动在视窗的最後加上 ``\''
                        ，而将其余 的文字移至下一列；若下一列还是无法显示出所有的文字，会在
                        此列的最後再加上一个 ``~续将多余的文字移至下一列。
                        EMACS 就是不断重复如此的动作，直到所有的文字都能完全显示出来为止。
                        所代表的意思与键入RET
                        并不相同。键入 RET
                        表示重新使用
                        一个新列；不键入 RET 而令 EMACS
                        自动加入所产生的文件，
                        仍代表著同一列，只是这一列太长，
                        EMACS 无法以其视窗的
                        宽度来一次穷尽，必须分为数次来表示。</li>
                    <li>不键入 RET ，也不使 EMACS
                        自动产生 ，而使超过萤幕宽度
                        的部份暂时隐藏起来。EMACS
                        处理这种情形，是在视窗的最後
                        加上一个 ``$'' 。 ``$'' 表示其後的内容在视窗上暂时看不到，
                        但仍安在缓冲区内。EMACS
                        的基本预设是自动加入 ``\''。要使
                        多余的文字隐藏起来，必须设定
                        ``truncate-lines'' 变数的值为正值。
                        变数设定的方法请参考 4.4 节。
                        4.4
                        节曾谈过一个视窗可以分成左右二个小视窗，此视窗可以
                        做水平的卷动，此情形下的视窗在处理太长的列时，就是将
                        truncate-line 变数的值设成正值，使超过宽度的文件隐藏起来。
                    </li>
                </ul>
            </dd>
            <dd>前面所谈的都是「文字」的插入方式，但如何插入一个「非文字」
                的空白列呢？在编辑的过程中，若想在某列之前加入一个新列，
                只需将游标移至此列的最前端
                ，随後再按下 RET 即可。此时 EMACS
                会在游标所在处的前一列， 加入一空白列。
                EMACS
                为何要将空白列加在游标之前而不是游标
                之後呢？因为将空白列加在游标之前，有一个最大好处，就是可以
                很轻易的在缓冲区的最前端加入一个空白列。
                此时所键入的 ``RET'' ，代表著 newline
                。若不键入 RET， 也可以 使用 EMACS
                所提供的 Hotkey ，也就是 Ctrl-j
                (tex-terminate-paragraph)
                来获得新的一列。 <hr>
                <h3><i>point</i>的移动</h3>
                <h4>文字的键入及显示是编辑过程不可或缺的。除此之外，移动游标到
                适当的位置，也是编辑过程不可缺的功能。现在就来看看在
                EMACS 下如何移动 <i>point</i>
                或可称为如何移动游标。移动 <i>point</i>
                也就是移动 游标，因为 <i>point</i>
                是透过游标来显示的。所以在本文会将游标与
                <i>point</i> 交互使用。
                游标移动不外乎以固定的单位，将其做上下左右的移动。此固定
                的单位可能是字元（character）、字（word）、列（line）或页（page）。
                现在就来看看如何将游标以这些单位来移动。
                </h4>
                <ul>
                    <li>左右移动一或数个「字元」（character）</li>
                    <li><ul>
                            <li>Ctrl-f（forward-char）</li>
                            <li>游标往前（右）移动一个字元。</li>
                            <li>Ctrl-u n Ctrl-f </li>
                            <li>(Ctrl-u n Meta-x forward-char)
                                游标往前（右）移动 n
                                个字元。</li>
                            <li>Ctrl-b（backward-char）</li>
                            <li>游标往回（左）移动一个字元。</li>
                            <li>Ctrl-u n Ctrl-b （Ctrl-u n
                                Meta-x backward-char）</li>
                            <li>游标往回（左）移动 n
                                个字元。</li>
                        </ul>
                    </li>
                    <li>游标左右移动一或数个「字」（word）</li>
                    <li><ul>
                            <li>Meta-f（forward-word）</li>
                            <li>游标往前（右）移动一个字。</li>
                            <li>Ctrl-u n Meta-f （Ctrl-u n
                                Meta-x forward-word）</li>
                            <li>游标往前（右）移动 n
                                个字。</li>
                            <li>Meta-b （backward-word）</li>
                            <li>游标往回（左）移动一个字。</li>
                            <li>Ctrl-u n Meta-b （Ctrl-u n
                                Meta-x backward-word）</li>
                            <li>游标往回（左）移动 n
                                个字。</li>
                        </ul>
                    </li>
                    <li>游标移至一列的「最前端」或「最尾端」</li>
                    <li><ul>
                            <li>Ctrl-a （beginning-of-line）</li>
                            <li>游标移至一列的最前端。</li>
                            <li>Ctrl-e （end-of-line）</li>
                            <li>游标移至一列的最尾端。</li>
                        </ul>
                    </li>
                    <li>游标上下移动「一列」或「数列」（line）</li>
                    <li><ul>
                            <li>Ctrl-n （next-line）游标向下移动一列。</li>
                            <li>下移一列的游标其所在的水平位置，与移动前的水平位置
                                相同。若游标在文件的最後一列时，
                                Ctrl-n 会自创新列再
                                移到此新列的第一个栏位。
                            </li>
                            <li>Ctrl-u n Ctrl-n(Ctrl-u n Meta-x
                                next-line)游标向下移动 n
                                列。</li>
                            <li>Ctrl-p （previous-line)游标向上移动一列。</li>
                            <li>上移一列的游标其所在的水平位置，与移动前的水平位置相同。
                                若游标已在文件的第一列时，再使用
                                `` Ctrl-p'' 时 <i>echo area</i>
                                会显示如下的讯息：
                                Beginning of buffer</li>
                            <li>Ctrl-u n Ctrl-p （Ctrl-u n
                                Meta-x previous-line） 游标向上移动
                                n 列。</li>
                        </ul>
                    </li>
                    <li>上下卷动缓冲区</li>
                    <li><ul>
                            <li>Ctrl-v（scroll-up）</li>
                            <li>向上卷动缓冲区，且将目前视窗所显示的最後二列，做为
                                卷动後的前二列， <i>point</i>
                                出现在视窗上的第一列。
                                EMACS 如此做只是让使用者
                                有一个承先启後的感觉罢了。</li>
                            <li>Ctrl-u n Ctrl-v </li>
                            <li>缓冲区向上卷动 n 列。
                                数字 n 若小於目前 <i>point</i>
                                在此视窗所在位置的列数，卷动後的
                                <i>point</i>
                                位置，仍留在卷动前的同一列上；否则
                                <i>point</i> 移至视窗
                                的第一列。</li>
                            <li>Meta-v（scroll-down）</li>
                            <li>向下卷动缓冲区，且将目前视窗上的前二列做为卷动後的後
                                二列，此时的 <i>point</i>
                                出现在萤幕的最後一列。</li>
                            <li>Ctrl-u n Ctrl-v </li>
                            <li>缓冲区向下卷动 n 列，
                                若数字 n 小於<i>point</i>
                                在此视窗以下的列
                                数，卷动後的 <i>point</i>
                                位置，仍留在卷动前的同一列处。否则
                                <i>point</i> 移至视窗的最後一列。</li>
                        </ul>
                    </li>
                    <li>左右卷动缓冲区 <ul>
                            <li>Ctrl-x &lt;（scroll-left）
                                缓冲区向左卷动。</li>
                            <li>Ctrl-x &gt;（scroll-right）
                                缓冲区向右卷动。</li>
                        </ul>
                    </li>
                    <li>游标移至缓冲区的前端尾端</li>
                    <li><ul>
                            <li>Meta &lt;（beginning-of-buffer)</li>
                            <li>将游标移至缓冲区的最前端，
                                <i>point</i> 也移至视窗的第一列。
                            </li>
                            <li>Meta &gt;（end-of-buffer）</li>
                            <li>将游标移至缓冲区的最尾端，
                                <i>point</i> 也移至视窗的最後一列。
                            </li>
                        </ul>
                    </li>
                    <li>页数的移动</li>
                    <li>还记得讨论 `` Ctrl-q''
                        (quoted-insert) 时，提过分页的控制码。
                        有了分页的设定，自然会有以页数做为移动游标的单位了。
                        <ul>
                            <li>Ctrl-x [ （backward-page）</li>
                            <li>将 <i>point</i>
                                移至上一页分页指标（^L）之後且紧邻
                                ^L。 若<i>point</i>
                                已紧邻在 ^L
                                之後了，则会略过此 F在
                                ^L 之後了， 则会略过此
                                ^L 到上一个 ^L 之後。 </li>
                            <li>Ctrl-x ] （forward-page）</li>
                            <li>将 <i>point</i>
                                移至下一页分页指标（^L）之後且紧邻
                                ^L。 若<i>point</i>
                                已紧邻在 ^L
                                之後了，则会略过此 F在
                                ^L 之後了， 则会略过此
                                ^L 到下一个 ^L 之後。 </li>
                            <li>Ctrl-x Ctrl-p （mark-page）</li>
                            <li>以页为单位做上记号之後，再配合其它的指令对此页做处理。
                                此指令类似mark region（5.4
                                节会讨论其意思）。例如
                                Ctrl-x Ctrl-p Ctrl-w
                                是将游标所在的那一页删掉。此指令可以配合
                                numeric arguments（5.3
                                节会讨论其意思）使用。
                            </li>
                        </ul>
                    </li>
                </ul>
            </dd>
            <dd>除了以移动游标的方法来游走缓冲区外，
                EMACS 还提供一个可以直接将游标移到指定的行列。所要到达的目的地，
                不论是以字元数或列数为移动的单位，其起算点都是以缓冲区
                的第一列第一个栏位为起算的标准。以下就是此方法的介绍。
                <ul>
                    <li>Meta-x goto-char RET </li>
                    <li>键入此指令後再按下 RET ，<i>echo
                        area</i> 会出现 ``游标移动的总字元数即可。再一次的提醒各位，字元的
                        计算是以缓冲区的第一列的第一个字元为起算点。例如，
                        在 ``Goto char:'' 给予 100
                        的数字，则游标会从缓冲区的
                        第一字元移动到第 100 个字元。
                    </li>
                    <li>Meta-x goto-line RET
                        键入此指令再按下 RET 後，<i>echo
                        area</i> 会出现 ``，
                        在其後输入想要游标移动的列数即可。再一次的提醒各位，
                        列数的计算是以缓冲区的第一列为起算列。例如，在
                        ``Goto line:'' 给予 100
                        的数字，则游标会从缓冲区的第一列开始往下移动
                        10 列。 </li>
                </ul>
                <hr>
                <h3>何谓数值引数</h3>
                <h4>在上一小节 <i>point</i>
                移动一文中不断的看到 Ctrl-u n
                ，它是什麽呢？ 它是 EMACS
                的数值引数（numeric argument），但数值引数
                又是什麽的呢？ </h4>
            </dd>
            <dd>数值引数适用於所有 EMACS
                的指令。它的用途可分成 以下数类：
                <ul>
                    <li>对某一指令做重复执行的动作 </li>
                    <li><ul>
                            <li>用法： Ctrl-u n command 或 </li>
                            <li>Meta- n command </li>
                            <li>说明： <ul>
                                    <li>n
                                        代表重复的次数；
                                        command 代表要重复执行的指令。</li>
                                    <li>若键盘提供 Meta
                                        键（个人电脑可以使用
                                        ESC 键），则 Meta
                                        键是使用数值引数最方便的方法。</li>
                                    <li>n
                                        若为负值的数字，则表示以反方向运行指令。</li>
                                </ul>
                            </li>
                            <li>例子： </li>
                            <li><ul>
                                    <li>n 为正值</li>
                                    <li>Ctrl-u 5 Ctrl-f 或
                                        Meta-5 Ctrl-f 表示游标往前（右）移动
                                        5 个字元。 </li>
                                    <li>n 负值</li>
                                    <li>Ctrl-u -5 Ctrl-f 或
                                        Meta-5 Ctrl-f 表示游标往回（左）移动
                                        5 个字元。 </li>
                                </ul>
                            </li>
                            <li>重复动作四次</li>
                            <li>用法： </li>
                            <li>说明： </li>
                            <li><ul>
                                    <li>Ctrl-u
                                        後面所接的不是数字而是字元，它代表著一个
                                        Ctrl-u
                                        重复指令的动作为一个四的倍数。换言之，一个
                                        Ctrl-u 执行
                                        四次，二个 Ctrl-u
                                        则执行 16 次，以此类推。</li>
                                </ul>
                            </li>
                            <li>例子： </li>
                            <li><ul>
                                    <li>Ctrl-u Ctrl-f</li>
                                    <li>表示游标往前移动
                                        4 个字元。 </li>
                                    <li>Ctrl-u Ctrl-u Ctrl-f</li>
                                    <li>表示游标往前移动
                                        16 个字元。 </li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                    <li>利用引数变数自动键入相同的「字元」</li>
                    <li><ul>
                            <li>用法： Ctrl-u n char 或 </li>
                            <li>Meta- n char </li>
                            <li>说明：省略 n
                                与否，代表不同的意义 </li>
                            <li><ul>
                                    <li>Ctrl-u
                                        後紧接著数字与字元，表示重复字元
                                        n 次。</li>
                                    <li>Ctrl-u
                                        後面不接数字而紧接字元，表示重复字元四次。</li>
                                </ul>
                            </li>
                            <li>例子： <ul>
                                    <li>Ctrl-u 10 r 或 Meta-10 r
                                        则萤幕上出现 10 个
                                        r。</li>
                                    <li>Ctrl-u r 或 Meta-4 r
                                        则萤幕上出现 4 个
                                        r。</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                    <li>使用引数变数自动产生相同的「数字」的方法</li>
                    <li><ul>
                            <li>用法： Ctrl-u n Ctrl-u n 或
                                Meta- n Ctrl-u n </li>
                            <li>说明： Ctrl-u 後面有二个
                                n ，第一个 n 表重复的次数，
                                第二个 n
                                表重复的数字。第二个 n
                                之前一定要再给予一次
                                Ctrl-u，若不给第二个
                                Ctrl-u ，系统会以为重复
                                nn 次。</li>
                            <li>例子： Ctrl-u 5 Ctrl-u 4 或
                                Meta-5 Ctrl-u 4 萤幕上出现 5
                                个 4。 Ctrl-u 5 4 ，则系统以为重复
                                54 次。</li>
                        </ul>
                    </li>
                </ul>
            </dd>
            <dd>数值引数的用途很广，且适用任何一个
                EMACS 的指令， 当需要重复执行某一指令的动作时别忘了它。有人说电脑最强大
                的功能之一，就是能不厌其烦的执行重复的事情。以下有关
                EMACS 指令的介绍，不再特别强调
                numeric arguments，
                但并不表示它就此而消失了，因为数值引数适合所有的指令，
                所以没有必要每次都重复强调。只需记得，需要时可随时使用
                numeric arguments。 <hr>
                <h3>如何得到与 <i>point</i> 有关的讯息</h3>
                <h4>前面谈过 EMACS 移动 <i>point</i>
                的方法，现在介绍探知 <i>point</i>
                位置 的方法。<i>point</i>
                所在的栏位、列数与页数等讯息，可从整个或部份
                的缓冲区而得知。现在就开始讨论 <i>point</i>
                位置。 </h4>
                <ul>
                    <li>Meta-x what-page </li>
                    <li>告知 <i>point</i>
                        所在的页数与列数。若缓冲区没有以分页（^L）符号
                        分页，则 <i>point</i>
                        所在的页数永远为第一页。 若 <i>point</i>
                        在第一页的 第 200
                        列，其显示的讯息如下： Page 1,
                        line 200 </li>
                    <li>Ctrl-x l （count-lines-page）</li>
                    <li>`` Meta-x what-page'' 用来告知 <i>point</i>
                        所在位置的页数与列数， 但无法从中得知此页的总列数。若想知道某一页的总列数，
                        必需靠 Ctrl-x l 来得知。 此指令除了得知某页的总列数外，同时还知道
                        <i>point</i> 所在位置之前
                        与之後的尚有的列数。使用此指令时，
                        <i>echo area</i> 会出现
                        如下的讯息： Page has 23 lines（20
                        + 4） <i>echo area</i>
                        出现的第一个数字为总列数，括号内的二个数字
                        分别代表<i>point</i> 所在处之前与之後的列数。括号内的两个数
                        是以<i>point</i> 为分界点 而得来的。所以当
                        <i>point</i>
                        不出现在某一列的第一个栏位时，
                        括号内二个列数的总和会比总列数多出一列，因为
                        <i>point</i> 所在的列
                        被重复计算了两次. 此指令在决定如何分页时可以帮上大忙，
                        因为可以轻易得知 <i>point</i>
                        前後的列数。 </li>
                    <li>Meta-x what-line</li>
                    <li>告知 <i>point</i>
                        在缓冲区的列数。若此时 <i>point</i>
                        在第 200 列， 则 <i>echo area</i>
                        会出现如下的讯息：</li>
                    <li>Ctrl-x =</li>
                    <li>指出游标所在栏位的字元资料。这些资料包括字元的八进位码、
                        字元所在的位置占整个缓冲区的比例（此比例以字元为基本单位）
                        以及字元所在的栏位。例如以此指令来得知此
                        ``a'' 字元的资料， <i>echo area</i>
                        会出现如下的资讯： Char: a
                        (0141) <i>point</i>=23905 of 38784 (62)
                        column 19
                        临时想知某一字元的八进位，也不妨试试此法。
                    </li>
                    <li>Meta-= </li>
                    <li>用来得知某特定区域（ region）的总列数与总字元数。
                        至於如何设定区域会在 5.3
                        节讨论。以此指令得知的结果如下所示：
                        Region has 200 lines, 2000 characters </li>
                    <li>Meta-x line-number-mode </li>
                    <li>以上所讨论的指令，只在使用指令时才会显示想要的讯息，
                        讯息的出现是无法长存的。
                        基於此，EMACS 提供了一个可使
                        讯息永久存在 line
                        的方法，那就是使用 `` Meta-x
                        line-number-mode''。 此指令可以在
                        mode line 上显示 <i>point</i>
                        所在的列数，直到离开
                        此状态或离开此视窗才会消失。若想使每次进入EMACS
                        都能 显示列数，最好的方法是在
                        ``.emacs'' 档加上如下的叙述：
                        (setq line-number-mode t) 如此一来，只要进入
                        EMACS ， mode line 会自动将列数显现出来。
                        至於自动显示栏位的方法，目前的
                        EMACS 尚未提供此服务。 </li>
                </ul>
                <hr>
                <h3>文件的删减</h3>
                <h4>修改文件不外乎将原有的文件删除後，再加入新的内容；
                或将现有的资料做重新的排列组合。现先讨论文件的删除部份，
                文件的重组就留待 5.4
                节再进行讨论。 </h4>
            </dd>
            <dd>EMACS
                中的删除有两种形式，一种是指文件的<i>
                killing</i>， 另一种则指文件的<i>deletion</i>。在
                EMACS 中所谓的 <i>killing</i>
                是指将文件从目前的缓冲区移到一个称为<i>kill-ring</i>
                <i>kill-ring</i>
                为一个变数的地方去。文件在缓冲区中是消失了，
                但却储存在 kill-ring ,variable这一个变数中。
                EMACS 可以有许多的缓冲区，但却只有一个
                <i>kill-ring</i> 的储存变数。
                也就是说，多个缓冲区彼此共享一个 <i>kill-ring</i>，而且也只有一个
                <i>kill-ring</i>。 EMACS 所设计共享的
                killing-ring
                的用意是让被遗弃的文件可以找回，
                而且各缓冲区彼此也可借由 killing-ring
                来建立一个互通的管道。
                所谓的互通就是把甲缓冲区的东西给乙，反之，也可把乙缓冲区的
                东西给甲。此模式在 EMACS 中就是透过
                <i>killing-ring</i> 来完成。
                因此，想从甲缓冲区中得到某些文件给乙缓冲区，只要将
                甲缓冲区的文件放入 <i>kill-ring</i>
                中，乙缓冲区就可以至此共享的 <i>kill-ring</i>
                中将文件取出。如此一来，就可以共享资源了。
            </dd>
            <dd>另一种模式的删除，在 EMACS 中称为 <i>deletion</i>。此种删除，
                并不将删除後的资料放入 <i>kill-ring</i>
                中，而是将删除的文件遗弃。
                此种情形的删除是无法失物复得的。
                以 <i>deletion</i>
                删除的资料，可以键入 <p>Ctrl-x u（undo)
                来找回。使用一次 `` Ctrl-x u，恢复前一个指令的景象；
                使用二次 Ctrl-x u，则恢复前二个指令的容貌，如此周而复始
                的使用 Ctrl-x u ，可恢复更改前的全貌。至於
                `` Ctrl-x u'' 更详细的 说明会在 5.5 节进一步讨论。
                </p>
            </dd>
            <dd>前已说过，不放入 <i>kill-ring</i>
                的指令称为 <i>deletion</i> 的指令。
                EMACS 删除字元、空白字元以及空白列的指令都不放入
                <i>kill-ring</i> 中的。具体说来就是，
                Ctrl-d、 DEL、 Meta-\、 Meta-SPC 与 Ctrl-x
                Ctrl-o 等指令。 现就为各位说明这些指令。
            </dd>
            <dd>文件的修改不是重组资料就是删减与新增资料，新增资料已
                论述过了，而重组资料即将在 5.4
                节登埸，现在就开始谈文件的删减
                。删除文件也不外乎删除一个字元、一个字、一行或一个区块；
                删除的方向可以选择左右删除的方式。现在就来看看如何以
                EMACS 所提供的指令，来做删除的工作。此处将删减的指令分成
                <i>deletion</i> 和 <i>killing</i>而大类。 <ul>
                    <li>属於 <i>deletion</i> 的指令集</li>
                    <li><ul>
                            <li>删除「字元」（character）的方法</li>
                            <li><ul>
                                    <li>Ctrl-d（delete-char）</li>
                                    <li>删除 <i>point</i>
                                        所在位置的字元。 </li>
                                    <li>DEL（delete-backward-char）</li>
                                    <li>删除 <i>point</i>
                                        之前的字元。
                                        此指令与 Ctrl-d
                                        为最基本的删除指令，只要耐心够，任何
                                        的删除都可以此二个指令完成。
                                    </li>
                                </ul>
                            </li>
                            <li>删除 spaces 和 tabs 的方法</li>
                            <li><ul>
                                    <li>Meta-\（delete-horizontal-space）</li>
                                    <li>输入资料时，常会不自觉的输入无意的空白（space）和
                                        tab 。
                                        当合并上下列而为一列时，也常会出现
                                        space 或 tab 从中作梗。
                                        为此 EMACS 提供了
                                        Meta-\ 的指令，让使用者可以很容易
                                        将不必要的 space 和
                                        tab 删除。当然其它的删除指令，也可以
                                        将不需要的 space 和
                                        tab 删除，此指令只是更方便删除
                                        space 和 tab 而已。
                                        Meta-\ 可删除 <i>point</i>
                                        前後所有的 space 和
                                        tab 。 例如：abc def
                                        g，此时的游标在 f
                                        与 g 之间。 键入了
                                        Meta-\ 其结果如下所示：
                                        abc defg </li>
                                    <li>Meta-SPC（just-one-space）</li>
                                    <li>删除 <i>point</i>
                                        前後的 space 和 tab
                                        时，若希望留下一个
                                        space 或 tab
                                        做为彼此的分隔，就必须使用
                                        `` Meta-SPC'' 来完成了。
                                        例如：abc def g，此时的游标在
                                        f 与 g 之间。
                                        键入了 `` Meta-SPC
                                        其结果如下所示：
                                        abc def g </li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                    <li>属於 <i>killing</i>的指令</li>
                    <li><ul>
                            <li>删除「字」（word）的方法
                                <ul>
                                    <li>Meta-d（kill-word）</li>
                                    <li>此指令往前（右）删除
                                        <i>point</i>
                                        所在位置的字。
                                        其所删除字的范围端赖
                                        <i>point</i> 所在的位置而有不同。
                                        若<i>point</i> 在一个字的第一个字元，则会删除此字；若
                                        <i>point</i> 在此字的
                                        其它位置，则删除 <i>point</i>
                                        所在位置及其之後的所有字元，包括
                                        <i>point</i> 所在位
                                        置的字元。
                                        例（一）： This is a
                                        test. 游标若在 test
                                        这个字的 t 处，使用此指令的结果如下：
                                        This is a . 例（二）：
                                        This is a test.
                                        游标若在 test
                                        这个字的 e
                                        处，使用此指令的结果如下：
                                        This is a t.
                                        若想删除一个以上的字，可以使用
                                        numeric argument 。 </li>
                                    <li>Meta-DEL（backward-kill-word）</li>
                                    <li>此指令往回删除 <i>point</i>
                                        所在位置的字。
                                        其所删除字的范围端赖
                                        <i>point</i>
                                        所在的位置而有不同。
                                        若 <i>point</i>
                                        在一个字的第一个字元，则会删除此字之前的字；
                                        若 <i>point</i>
                                        在此字的其它位置，则删除
                                        <i>point</i>
                                        之前的所有字元，但不包括
                                        <i>point</i> 所在
                                        位置的字元。
                                        例（一）： This is a
                                        test. 游标若在 test
                                        这个字的 t 处，使用此指令的结果如下：
                                        This is test. 例（二）：
                                        This is a test.
                                        游标若在 test
                                        这个字的 e
                                        处，使用此指令的结果如下：
                                        This is a est.
                                        同样的，回想一下
                                        numeric argument 吧。 </li>
                                </ul>
                            </li>
                            <li>删除列的方法</li>
                            <li><ul>
                                    <li>Ctrl-k（kill-line）</li>
                                    <li>删除列的指令。所删除列的范围，以
                                        <i>point</i>
                                        所在的位置为
                                        准则， 以 <i>point</i>
                                        所在位置为起始点，以此列的结束为终点。
                                        被删除掉的文件会在视窗上留下一空白，若想将空白列也一并删除，
                                        必需再使用一次
                                        Ctrl-k。此时的 Ctrl-k
                                        是用来删除换列指令
                                        的控制码。 </li>
                                    <li>Ctrl-x Ctrl-o（delete-blank-lines）</li>
                                    <li>编辑的过程中会不经意的加入许多空白列，此种情形常发生在
                                        缓冲区的最尾端。每按下一个
                                        RET
                                        ，就输入了一个新列，但在缓冲区
                                        的尾端按下 RET
                                        ，此时所加入的新列并不易为人查觉。此指令可以
                                        将<i>point</i>所在位置「前後」的空白列删除只留下一列。当然并非
                                        一定要以此指令来删除空白，
                                        Ctrl-k
                                        自然也可以用来删除空白列，
                                        也可以将空白列以删除区块的方式删除之，提供此指令只是方便满足
                                        使用者的需求而已。
                                    </li>
                                </ul>
                            </li>
                            <li>删除区块的方法</li>
                            <li><ul>
                                    <li>*Ctrl-w (Kill-region)
                                        EMACS 允许删除某一特定的区块。要删除区块，必需先标示区块，
                                        此标示的动作称为
                                        mark\。如何标示区块,就是下一节的主题。
                                    </li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                </ul>
            </dd>
            <dd>EMACS 对於被 <i>killing</i>而删除的资料，都是放在
                <i>kill-ring</i> 中。 <i>kill-ring</i>
                其实只是一个变数而已，所有 <i>killing</i>删除掉的文件，
                就是此变数的值。其已述及查阅变数值的方法，现不厌其烦的再论述一次：
                <ol>
                    <li>键入 ``Ctrl-h v'' 後， <i>echo area</i>
                        处会出现：</li>
                    <li>在 Describe variable:後输入变数的名称，
                        EMACS 会另开一个 视窗来显示此变数的值。此时所要键入的变数名为
                        ``<i>kill-ring</i>''</li>
                </ol>
                <p>此节讨论 EMACS
                编辑的基本指令，有了这些指令之後，编辑的工作
                就不是难事了。接下来各节则讨论其它的编辑功能。
                </p>
                <hr>
                <h2><a name="3">何谓 Yanking</a></h2>
                <h4>将 kill ring
                的内容取出的动作，称为 <i>yank</i>。 <i>yank</i>
                除了可 <i>yank</i> 最新 killing
                的资料，也可 <i>yank</i> 早先 <i>killing</i>的内容。现在就以二种不同的
                <i>yank</i> 做为讨论的对象。 将最新 <i>killing</i>的文件从
                <i>kill-ring</i>中取出的方法
                很简单，只要使用 `` Ctrl-y'' 即可。
                但在 <i>yank</i> 时，一定要确保 在 <i>killing-ring</i>
                中存有被删除的资料。 想要 <i>yank</i>
                最新 <i>killing</i>之前的文件，就较为复杂了。所谓的
                较为复杂，只是多了一个移动指向 <i>kill-ring</i>
                变数值的程序而已。 因为 <i>yank</i>
                指令所要<i>yank</i>
                的内容，全视指标指向 <i>kill-ring</i>
                的位置而定。此指标一般都是指向最新放入的文件。若想
                <i>yank</i> 其它的内容，就必需先移动指标了。
                </h4>
            </dd>
            <dd>移动 <i>kill-ring</i> 指标的方法是使用
                `` Meta-y'' (<i>yank</i>-pop)， 但在使用 ``
                Meta-y'' 之前，一定要先使用 `` Ctrl-y''。
                换言之， `` Meta-y'' 的使用，一定要紧跟在
                `` Ctrl-y'' 之後。 </dd>
            <dd>`` Meta-y'' 的运作是将指向 <i>kill-ring</i>
                入口的指标，向前移动， 再将``
                Ctrl-y'' <i>yank</i> 出来的资料
                ，以此时指标指向的文件取而代之。
                这就是为何使用 `` Meta-y'' 指令之前，一定要先执行
                `` Ctrl-y''。 以 `` Meta-y'' 来移动指标，并不会影响
                <i>kill-ring</i> 变数值的内容次序。 <hr>
                <h2><a name="4">如何在文件中做上标记</a></h2>
                <h4>前面有些指令是专门运作区块的，如
                `` Ctrl-x Ctrl-p'' 与 `` Ctrl-w'' 等等。
                但什麽是区块呢？ EMACS
                所言的区块，是指从标记（ mark）处到
                <i>point</i>
                所在位置间的范围，此范围就是区块（
                region)了。 换言之，区块的范围是指，标记所在位置之後（包括标记所在位置本身）
                到 <i>point</i>之前（不包括 <i>point</i>
                所在的位置）的所有文件。 知道区块的定义後，接下来就介绍如何定义区块了。
                </h4>
            </dd>
            <dd>既然区块是指从标记处到 <i>point</i>的范围，自然设定区块也意味著
                设定标记和 <i>point</i>。设定 <i>point</i>的方法很简单，只要移动
                <i>point</i>至目的地即可。此时的 <i>point</i>代表著区块范围的终点。
                至於设定标记的方法也不难，只要在想要设定标记的地方，输入以下的
                任一个指令即可。 <ul>
                    <li>Ctrl-@ （set-mark-command）</li>
                    <li>Ctrl-SPC （set-mark-command）</li>
                </ul>
                <p>所以设定区块的步骤如下所示： </p>
                <ol>
                    <li>设定区块的始位置，也就是所谓的标记（
                        mark）。</li>
                    <li>可使用 `` Ctrl-@'' 或 `` Ctrl-SPC''
                        任一个指令来设定标记。 </li>
                    <li>设定区块的终结位置，也就是移动游标至区块的尾端。</li>
                </ol>
                <p>在标记与 <i>point</i>之间的范围就是所谓的区块。
                </p>
            </dd>
            <dd>为何会提供二个设定标记的 Hotkey
                呢？ Hotkey 是用来连结 EMACS 的命令，
                EMACS 会将常用的命令给予一个 Hotkey
                与之连结。 此连结的Hotkey，常会受所使用的终端机而不同。因此有的终端机
                可以使用 `` Ctrl-@''，但有的终端机则必需使用
                `` Ctrl-SPC''。更甚者， 有的终端机却二者都无法使用，例如笔者以个人电脑模拟成的终端机，
                却必需键入 `` Ctrl-2''
                才能达到设定标记的效果。 EMACS
                可以允许使用者 重新设定所使用的
                Hotkey ，但这已经超过本文讨论的范围。如果无法
                使用以上任何一个 Hotkey
                ，就使用命令 <p>`` ESC-x set-mark-command''。</p>
                <p>使用 EMACS 的指令（ command）永远可以达到目的的。
                </p>
            </dd>
            <dd>EMACS 的 <i>point</i>，是透过视窗上的游标来显示的。
                text-only 视窗只有一个游标，所无法同时表示标记及
                <i>point</i>。
                若想观测区块的来龙去脉，可以 ``
                Ctrl-x Ctrl-x''<p>（exchange-<i>point</i>-and-mark）</p>
                <p>将标记与<i>point</i>做交换，从交换的过程可以观察标记与
                <i>point</i>的位置。 `` Ctrl-x Ctrl-x''
                所能做的事，只互换标记与 <i>point</i>而已。
                </p>
            </dd>
            <dd>那些指令是使用在区块上呢？以下指令就是适用在区块上的。
                有些是曾经提过的，有些是将要谈及的，有些可只能只是列举出来
                并不会在本文中被讨论。 <ul>
                    <li>Ctrl-w（kill-region）</li>
                    <li>Ctrl-x r s（copy-to-register）</li>
                    <li>Ctrl-x Ctrl-p（mark-page）</li>
                    <li>Ctrl-x Ctrl-l（downcase-region）</li>
                    <li>Ctrl-x Ctrl-u（upcase-region）</li>
                    <li>Meta-x fill-region</li>
                    <li>Meta-x print-region</li>
                </ul>
                <p>接下来讨论与编辑有切身关系的搬移与拷贝。
                </p>
                <hr>
                <h2><a name="5">文件的移动与拷贝</a></h2>
                <h4>变换文件在缓冲区出现的位置称为搬移（在缓冲区的其它地方重复出现
                称为拷贝（ Copy）。 </h4>
            </dd>
            <dd>前已论及放於 <i>kill-ring</i>
                的文件，可在需要时拿出来使用，
                此动作称为 <i>yank</i>\index<i>yank</i>
                。使用 <i>yank</i> 的方法 很简单，只要键入
                ``Ctrl-x y''即可。使用此方法可将某特定区块的文件
                做「搬移」的动作，只是所需的步骤比较烦琐而已。首先将要搬移的文件
                重复以 `` Ctrl-x k'' 的指令，将其放入 <i>kill-ring</i>
                中，再将 <i>point</i> 移至文件欲搬移的位置，以
                `` Ctrl-y'' 将其 <i>yank</i> 出来。 </dd>
            <dd>「拷贝」一个区块的方法与「搬移」一个区块的方法累同，唯一
                不同是要执行二次 <i>yank</i>
                。第一次使用 <i>yank</i>，是将删除的
                原文件再放回被删除的位置，第二次使用
                <i>yank</i> 是做拷贝的动作， 也就是将
                <i>kill-ring</i> 的文件放入要拷贝的地方。
            </dd>
            <dd>以上的方法当然可以用来做搬移和拷贝之用，但如要搬移和拷贝的文件
                有数十甚至数百数千列，岂不要重复
                `` Ctrl-k'' 的动作数十甚至数百数千次。
                因为 `` Ctrl-k''
                基本上是删除列的指令，当然删除列的指令，可以配合
                numeric argument。但在使用数值引数之前还必需确定所欲搬移或拷贝的确实列数，
                如此一来岂不使事情愈来愈复杂呢？所以，要搬移与拷贝文件最好的方法，
                就是使用标记与区块。下面所谈的是针对区块的搬移与拷贝的方法。
            </dd>
            <dd>不论搬移或拷贝，只要触及区块的使用，首要之事就是先把区块标示出。
                区块定好之後，要搬移就以 `` Ctrl-w''，
                将整个区块删除之後，再以 `` Ctrl-y''
                将其 <i>yank</i> 出来。要拷贝则以 ``
                Meta-w'' 将区块的内容 拷贝一份放在 <i>kill-ring</i>
                中，尔後再以 `` Ctrl-y'' 将其 <i>yank</i>
                出来。现说明搬移与拷贝的实际操作过程。
                <ul>
                    <li>不设定区块，以删列的方式，将文件一列列先删除後,再
                        <i>yank</i> 出来。
                        此法可搬移与拷贝 <i>kill-ring</i>
                        内的文件。</li>
                    <li><ol>
                            <li>重复执行 `` Ctrl-k''（删除文件，可使用
                                numeric argument）</li>
                            <li>Ctrl-y（将放置在 kill ring
                                中的文件，<i>yank</i>
                                至缓冲区内。）</li>
                            <li><ul>
                                    <li>若做搬移的动作，只需使用一次
                                        <i>yank</i>。</li>
                                    <li>若做拷贝的动作，则要使用二次的
                                        <i>yank</i>。</li>
                                </ul>
                            </li>
                        </ol>
                    </li>
                    <li>以设定区块的方式，「搬移」区块的文字。</li>
                    <li><ol>
                            <li>Ctrl-@（设标记，也就是设定区块的起始值）</li>
                            <li>移动游标以便设定 <i>point</i>的位置（设定区块的终点）</li>
                            <li>Ctrl-w（删除所标示的区块）</li>
                            <li>移动游标至要搬移的位置（确定文件搬移处）</li>
                            <li>Ctrl-y（将放置在 kill ring
                                中的文件，<i>yank</i>
                                至缓冲区内。）</li>
                        </ol>
                    </li>
                    <li>以设定区块的方式，「拷贝」区块的文字。</li>
                    <li><ol>
                            <li>Ctrl-@（设标记 (mark)）</li>
                            <li>移动游标以设定 <i>point</i>的位置（设定区块的终点）</li>
                            <li>Meta-w（不删除标示区块的内容，将此内容拷贝至
                                <i>kill-ring</i> 中）</il> </li>
                            <li>移动游标至要拷贝的位置（确定文件拷贝处)</li>
                            <li>Ctrl-y（将放置在 <i>kill-ring</i>
                                中的文件，</li>
                            <li><i>yank</i> 至缓冲区内。）
                            </li>
                        </ol>
                    </li>
                </ul>
                <p>为了更清楚搬移与拷贝後的真实结果，现举实例来说明。
                </p>
            </dd>
            <dd>实例：现有二段文件，第一段文字是做搬移与拷贝用的，
                第二段文字是用来接收搬移後的文字。
                第一段：标记设在第一列的 A 处，而 <i>point</i>设在
                B 的地方。 1111111111A22222222222
                3333333333333333333333 4444444444444444444444
                55555B5555555555555555 第二段： <i>point</i>在
                Y 处 00000Y0000000000000000
                0000000000000000000000 0000000000000000000000
                结果一、将第一段的文件搬移至第二段，搬移後的游标仍在
                Y 处。 1111111111B5555555555555555
                00000A22222222222 3333333333333333333333
                4444444444444444444444 55555Y0000000000000000
                0000000000000000000000 0000000000000000000000
                结果二、将第一段的文件拷贝至第二段，搬移後的游标仍在
                Y 处。 1111111111A22222222222
                3333333333333333333333 4444444444444444444444
                55555B5555555555555555 00000A22222222222
                3333333333333333333333 4444444444444444444444
                55555Y0000000000000000 0000000000000000000000
                0000000000000000000000 执行搬移与拷贝的动作时，
                EMACS 所采取的一律是 insert-mode。此时，即使设定为覆盖（
                overwrite-mode）， 覆盖的效果也会暂时失效。
            </dd>
            <dd>区块的范围以标记（mark）为起始值，以
                <i>point</i>所在位置之前 的字元做结束。所以，从以上的实例可以很清础的看到，搬移或拷贝之後
                的文件会包括标记所在的字元，但不会包含
                <i>point</i>所在的字元。
                搬移或拷贝的文件会出现在 <i>point</i>之前，原先所有的文件会向後移动，
                此时的 <i>point</i>仍在移动前的字元处。
            </dd>
            <dd>区块是以标记为开始而以 <i>point</i>为终点所构成的。标记与
                <i>point</i>所在的列，可能包含所在列的一部分，其它区块所包含的列都是完整的
                一列。若搬移或拷贝的范围，为文件中某一个长方形的区域，那该如何来设定
                其范围呢？设定好的范围又该如何来操作呢？
                EMACS 对於这种形状的区域有其它
                的处理方式，称为长方形的区块 （
                rectangle region）。 </dd>
            <dd>设定长方形（ Rectangle)的方法与设定区块（
                Region）的方法是一样的 ，只是在理解上有所不同。长方形设定的方法，也是设定二个标记，
                此两个标记位於长方形相对的两个直角上。所以，设定了左上角，
                另一个标记一定要设在右下角；反之，如果设定了右上角，另一个标记就一定
                要在左下角了。。此所设好的长方形，
                EMACS 称为 rectangle 。
                长方形与区块的设定方法是一样，所以单从设定标记与
                <i>point</i>的方式
                ，是无法辨识二者的差别的。要知是使用区块或长方形，只有等到使用运作
                於此范围的指令时才会知道。
                若是以删除长方形的指令将长方形的区块删除时，此时删除掉的长方形文件
                并不放在 一般的 <i>kill-ring</i>
                中，而是放於别的地方。因为删除长方形的
                运作方式与删除区块的方式不同，所以将长方形删除後的内容，与放置区块
                删除後的内容分隔，以便管理。
                长方形运作的种类与区块运作的种类累同，可分为二大类，一类
                为删除与插入，另一类则专门用来处理空白。
                删除长方形可以采取摒弃的方式 （
                Ctrl-x r d）或将其储存於某处（ Ctrl-x r
                k)，以利事後的 <i>yank</i> ( Ctrl-x r y）
                (<i>yank</i>-rectangle)。 删除掉的长方形资料的保存，只能保留最新删除的资料，所以只有最新
                删除掉的长方形资料，才可以被 <i>yank</i>
                出来。 </dd>
            <dd>长方形区块的运作种类，除了能将资料做删除与搬移外，还可以
                在文件的某处加入固定区域的空白。因为从事编辑时，常需要在某一
                区域加入一些空白（ Ctrl-x r o）(open-rectangle)。
                例如在文件加上空白做为边缘（margin）；制作图表时留些空白；或将
                某一区域的文件以空白取代（ Meta-x
                clear-rectangle）等等。长方形 的运作与区块的运作最大不同处在於，无法直接做拷贝的动作，若要拷贝
                必需先删除後再执行二次的 <i>yank</i>。现在就说明长方形区域的用法。
                <ul>
                    <li>长方形区域的 <i>yank</i> 方法 <ol>
                            <li>Ctrl-@（设定长方形区域的第一个对角）</li>
                            <li>移动 <i>point</i>至第二个对角处（设定长方区域的第二个对角）</li>
                            <li>Ctrl-x r k（kill-rectangle）</li>
                            <li>删除设定好的长方形，以便
                                <i>yank</i> 使用。</li>
                            <li>移动 <i>point</i>到要 <i>yank</i>
                                的地方。</li>
                            <li>Ctrl-x r y（<i>yank</i>-rectangle）</li>
                            <li>将删除的长方形，从储存处取出。
                            </li>
                        </ol>
                    </li>
                    <li>永远删除长方形的内容</li>
                    <li><ol>
                            <li>Ctrl-@（设定长方形区域的第一个对角）</li>
                            <li>移动 <i>point</i>至第二个对角处（设定长方区域的第二个对角）</li>
                            <li>Ctrl-x r d（delete-rectangle）</li>
                            <li>删除设定好的长方形区域。此删除不会储存在某一定地方。换言之，
                                一旦摒弃此区域，就无法将其唤回，除非使用
                                undo 的指令。 </li>
                        </ol>
                    </li>
                    <li>在长方形区域内插入空白，原文件向前（右）移动。</li>
                    <li><ol>
                            <li>Ctrl-@（设定长方形区域的第一个对角）</li>
                            <li>移动 <i>point</i>（设定长方区域第二个对角）</li>
                            <li>Ctrl-x r o（open-rectangle）</li>
                            <li>填入空白在设定好的长方形区域内。此时区块内的文字会自动往右
                                移动。使用 overwrite mode，原有的文件也不会被加入的空白覆盖。
                            </li>
                        </ol>
                    </li>
                    <li>将设定的长方形区域以空白覆盖</li>
                    <li><ol>
                            <li>Ctrl-@（设定长方形区域的第一个对角）</li>
                            <li>移动 <i>point</i>至第二个对角处（设定长方区域第二个对角）</li>
                            <li>Meta-x clear-rectangle</li>
                            <li>将此长方形区块内的文件以空白取代。
                            </li>
                        </ol>
                    </li>
                    <li>在设定的长方形区域内填充某一类型的字串。</li>
                    <li>此方法常可用在程式的撰写或测试上。例如，测试
                        ``.emacs'' 程式时，常因测试的过程中，需要将设定做增减的工夫，
                        使用此方法可以随时将测试条件做增减。
                        <ol>
                            <li>Ctrl-@（设定要填充字串的起点）</li>
                            <li>移动 <i>point</i>至第二个对角处（设定要填充字串的终点）</li>
                            <li>键入 Meta-x string-rectangle
                                RET ，此时 <i>echo area</i>
                                会出现</li>
                            <li>String rectangle: 利用 <i>minibuffer</i>
                                键入要填充的字串，即可将字串填入长方形区内。
                                值得注意的是，此时长方形的宽度由字串的宽度来决定，
                                Ctrl-@ 与 <i>point</i>只用来决定长方形的长度。
                            </li>
                        </ol>
                    </li>
                </ul>
                <hr>
                <h2><a name="6">何谓 Undo</a></h2>
                <h4>在 EMACS
                中想要将已经做过的动作放弃，以恢复旧观。
                EMACS 将其 称为 undo，以下就介绍如何 <i>undo</i>：
                </h4>
                <ul>
                    <li>Ctrl-x u（<i>undo</i>） </li>
                    <li>Ctrl-\_ （<i>undo</i>） </li>
                </ul>
            </dd>
            <dd>以上两个 Hotkey 都是用来执行 <i>undo</i>
                的指令。 提供二个 Hotkey，是因为有些键盘并无明显使用
                `` Ctrl-\_'' 的方法，
                为了弥补无法以一个字元达到 <i>undo</i>
                效果的键盘，故另行提供 `` Ctrl-x u''
                给无法使用 `` Ctrl-\_'' 的使用者。 </dd>
            <dd>EMACS 所提供的 <i>undo</i>，可以连续恢复最近使用过的指令。
                <i>undo</i> 的顺序是最新使用过的指令最先被
                <i>undo</i> ，第二次使用 <i>undo</i>
                则恢复第二新的指令，任何指令的输入（除了
                <i>undo</i> 本身之外）
                都会使指令输入的顺序 重整， 这也同时影响
                <i>undo</i> 的顺序。 </dd>
            <dd>使用 <i>undo</i> 有一个限制，就是 <i>undo</i>
                只能 <i>undo</i> 对缓冲区内容造成改变的指令。对於只是改变游标动作的指令，是无法以
                <i>undo</i> 来恢复旧观。若所有修改过内容的指令，都以
                <i>undo</i> 恢复原状後， 再一次使用 <i>undo</i>
                的指令，<i>echo area</i>
                会出现如下的讯息： no furter <i>undo</i>
                information 当使用了 <i>undo</i>
                之後，还想要在 redo 这个已被 <i>undo</i>
                的动作时， 有一个技巧可以达成如此的效果。
                <ol>
                    <li>首先键入一个不会改变缓冲区内容的指令（如游标移动的指令），使原来</li>
                    <li>存放指令的顺序因新指令的加入而改变。
                    </li>
                    <li>再使用一次 <i>undo</i>
                        的指令，就可以达到 redo
                        的效果了。</li>
                </ol>
                <p>现举一实例来说明此 &gt;
                视窗上现有的资料为： This is a test. </p>
            </dd>
        </dl>
    </li>
    <li>如下为所执行的一连串指令，括号内表示所用过的指令：</li>
    <li><ol>
            <li>执行四次 DEL
                ，视窗显示如下的讯息：</li>
            <li>This is a 所使用的指令集如下： DEL DEL
                DEL DEL </li>
            <li>将游标至字元 ``i''
                处，视窗显示的讯息并无改变：</li>
            <li>This is a 所使用的指令集如下： DEL DEL
                DEL DEL </li>
            <li>键入 Meta-d，视窗显示如下的讯息：</li>
            <li>This a 所使用的指令集如下： DEL DEL DEL
                DEL Meta-d </li>
            <li>键入 Ctrl-x u，视窗显示如下的讯：</li>
            <li>This is a 此时恢复最新被使用过指令
                ``Meta-d'' 前的状况 （Ctrl-x u
                不为恢复的对象），也就是步骤二的情形。
                此时使用的过指令集如下： DEL DEL DEL
                DEL Meta-d Ctrl-x u </li>
            <li>键入 Ctrl-f，视窗仍出现与先前相同的讯息：</li>
            <li>This is a 所使用的指令集则增加如下：
                DEL DEL DEL DEL Meta-d Ctrl-x u Ctrl-f </li>
            <li>此时可以 Ctrl-x u 恢复第一次 <i>undo</i>
                前的状况， 即步骤三的状况。视窗出现：</li>
            <li>This a
                因为记录指令历史的指标，此时己在第二个
                Ctrl-x u 处，但 Ctrl-x u Ctrl-f 均不在 <i>undo</i>
                的行列中，所以此时可以再恢 复一次
                Meta-d 前的状况。 所使用的指令集如下：
                DEL DEL DEL DEL Meta-d Ctrl-x u Ctrl-f Ctrl-x u </li>
        </ol>
    </li>
</ul>

<pre>一般而言，每一个使用过的编辑指令都有一个与之相对应的  <i>undo</i> 记录。
每一个  <i>undo</i> 的记录，都只对目前的缓冲区有效。有的指令需要一个
以上的  <i>undo</i> 记录来完成  <i>undo</i> 的动作；有的指令会先汇集一群
 <i>undo</i> 的记录，当使用  <i>undo</i> 时，会将此汇集的结果一次展现出来。
例如，单一字元运作的指令，若每次使用  <i>undo</i> ，只恢复一个字元则
非常的不经济，所以遇到此种情形，以集合体的方式处理是比较合理的作法。
</pre>

<hr>

<pre><a href="index.html">回主选单</a></pre>
</body>
</html>
