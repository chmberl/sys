<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=gb_2312-80">
<meta name="GENERATOR" content="Microsoft FrontPage Express 2.0">
<title>与 Emacs 有关的议题</title>
</head>

<body>

<h1>与 Emacs 有关的议题</h1>

<h4>上一章简介了 EMACS
的整合环境，在讨论编辑之前，先介绍 如何启动
EMACS 与离开 EMACS； EMACS 对於萤幕的安排如何；
以及缓冲区与视窗在 EMACS 中角色定位等等的问题。
EMACS 可用在 text-only 的终端机与 X window System 的视窗环境，但本文只针对
text-only 的终端环境来说明任何有关 EMACS 的介绍。
</h4>

<h2><a name="1">如何起动 Emacs</a></h2>

<pre><a name="1">启动 EMACS 的方法非常简单，只要在 shell 的提示下键入 
``emacs'' 五个英文字就可以启动 EMACS 了。例如：

        $ emacs RET


启动後的 EMACS 做了如下的启始（initialize）动作：

</a></pre>

<ol>
    <li><a name="1">清除目前的萤幕，开始一个全新的
        EMACS 萤幕。</a></li>
    <li><a name="1">EMACS
        会在这个全新的萤幕，显示一些与 EMACS
        有关的 基本讯息。其中包括，目前使用的
        EMACS 版本、基本的线上 辅助说明讯息以及有关
        EMACS 版权的相关资讯等等。</a></li>
    <li><a name="1">此时若不输入任何指令， EMACS
        会在一段时间之後（约二分钟)
        自动将萤幕重新清除成一个空白的萤幕。</a></li>
    <li><a name="1"></a>　</li>
    <li><a name="1">若在萤幕自动重新清除之前键入指令，EMACS
        会根据 所给予的指令来做适当的运作。</a></li>
</ol>

<dl>
    <dd><a name="1">启动 EMACS
        的方法，不需要给予任何的档名，只要
        输入 emacs。因为 EMACS 是要建立一个能同时开启多个档案的
        编辑环境；更进一步希望开启的档案，能彼此共享一些讯息。
        所以，在键入 ``emacs''
        的同时，给予所要编辑的档名，就变得
        不实际了。 </a><hr>
        <h2><a name="2">如何离开 Emacs</a></h2>
        <h4>知道如何启动 EMACS
        後，接下来就要探讨如何离开 EMACS 了。
        离开 EMACS 的方法有两种，一种是暂时离开
        EMACS（suspending EMACS）， 另一种是永远离开
        EMACS（killing EMACS)。其使用方法如下
        （为求统一，以後的各章节都先列出 EMACS
        的Hotkey，其相对 应的命令则列举在小括号内，若无
        Hotkey 则直接列出其命令。 要使用EMACS
        的命令，通常要在每个命令前加上 Meta-x 或
        ESC-x ）： </h4>
        <ul>
            <li>Ctrl-z （suspend-emacs）</li>
            <li>暂时离开 EMACS
                回到其上一层的状态，一般是回到
                shell 的状态。 若想回到 EMACS
                的状态，只要键入 ''%emacs''，则可以回到
                EMACS 了。 </li>
            <li>Ctrl-x Ctrl-c（save-buffers-kill-emacs）</li>
            <li>永久离开 EMACS。以此方法离开 EMACS，除了重新启动
                EMACS 方外（即在 shell 的提示下键入
                emacs），没有其它的方法可以 再回
                EMACS 了 。 </li>
        </ul>
    </dd>
    <dd>暂时离开 EMACS 意思是回到上一层的状态（parent
        process）， 一般是指 shell。使用者可以随时回到原先所启动的
        EMACS 下， 对於所使用的缓冲区、kill ring以及
        undo history等相关资讯，
        仍保持与离开前相同的状态(有关 kill ring 、undo
        history 等相关
        资料会在以後的各章陆续提及。以 Ctrl-z
        (suspend-emacs) 指令暂时离开的 EMACS ，可以在
        shell 的提示下，以 ``%emacs'' 回到 离开前的
        EMACS 下。有些系统或 shell
        并不提供这种暂时离开的功能，
        此时只能永远离开 EMACS 而无法暂时离开
        EMACS 了。 </dd>
    <dd>要永远离开 EMACS 则必需键入 ``Ctrl-x
        Ctrl-c''(save-buffers-kill-emacs) 或 ``ESC-x
        save-buffers-kill-emacs''， EMACS 接收此指令後
        会展开如下的动作： <ol>
            <li>EMACS
                会主动提醒使用者，储存所有修改过的档案。</li>
            <li>　</li>
            <li>当使用者对需要储存的档案做了适当的处理後，
                EMACS 对於所有仍在执行的subprocess，也会主动提醒使用者是否要结束
                它们。因为离开 EMACS 的同时也就是结束这些
                subprocess 的时侯。</li>
        </ol>
    </dd>
    <dd>在永久离开 EMACS 前， EMACS
        会再三的提醒使用者 有关档案的储存与仍在执行的程式等等。因为，一旦永久离开
        EMACS 之後，所有未存档或尚在执行的
        subprocess 都会随之消失。 EMACS 对於所有未储存的档案与仍在进行的程序，会利用
        <i>echo area</i> 一一提醒遗忘它们的使用者。 <i>echo
        area</i> 会提示需要储存的档案，同时也提供可处理这些档案的方法。
        所以 <i>echo area</i> 除了显示要存档的档案名称外，还会
        在档名之後出现如下的讯息： （y, n, !, ., q,
        C-r or C-h） 这些讯息提供，就是要让使用者对於档案或程序有适当处理的机会。
        现在就对这些讯息做一讨论。 <ol>
            <li>y</li>
            <li>同意对 <i>echo area</i>
                所显示的缓冲区存档，并徵询对於
                其它档案是否存档的意见。</li>
            <li>n</li>
            <li>放弃对 <i>echo area</i>
                所显示的缓冲区存档，但徵询对於其它
                档案是否存档的意见。</li>
            <li>!</li>
            <li>同意对 <i>echo area</i>
                所显示的缓冲区存档，且对其它的
                缓冲区也一并存档，不再徵询其它档案是否存档的意见。</li>
            <li>.</li>
            <li>同意对 <i>echo area</i>
                所显示的缓冲区存档，但对其它的
                缓冲区则不再徵询是否存档的意见，直接放弃其它缓冲区的存档，
                且离开此存档的状态。</li>
            <li>q</li>
            <li>放弃存档的状态而不执行任何存档的动作。</li>
            <li>C-r</li>
            <li>此指令可用来流　目前所要储存的档案内容，当离开此流　状态
                即回复存档的模式，系统会再度询问与存档有关的讯息。</li>
            <li>C-h<p>对於以上的选项若有不明白的地方，可以此功能查阅其意思。
                </p>
            </li>
        </ol>
        <hr>
        <h2><a name="3">EMACS 的萤幕安排</a></h2>
        <h4>在 text-only 的终端机启动 EMACS 时， EMACS
        会占据整个萤幕， 此时的萤幕称为<i> frame</i>。再一次的强调，本文只讨论
        text-only 的 终端机，至於 X Window
        的环境则不在讨论的行列中。 </h4>
    </dd>
    <dd>text-only 的 <i>frame </i>又由数个 window
        所组成。 启动 EMACS 时，会产生二个预设的视窗，一个视窗用来输入一般
        的文件，在未有文件输入前先用来展示前面提到的
        EMACS 版本、 线上辅助说明以及有关版权等讯息；另一个视窗用来输入指令
        或是用做讯息的回应，称为 <i>minibuffer</i>或
        <i>echo area</i>。 </dd>
    <dd>若终端机提供反白的功能，在反白区域以上的地方是用来输入
        文件的视窗；反白区域以下的地方则是<i>
        minibuffer</i> 或 <i>echo area</i>。
        此反白的长条型则称为 <i>mode line</i>，它是用来描述输入文件视窗
        的一些讯息。现在就来谈谈组成 EMACS <i>frame
        </i>的这三个部份。 </dd>
    <dd>有关文字视窗的部份，因为还牵涉到缓冲区的问题，
        现在先略过不谈，下一节再行讨论。现在先讨论与其有关的
        <i>mode line</i>和位於 <i>mode line</i>下的<i>minibuffer</i>
        或 <i>echo area</i>。 </dd>
    <dd><i>mode line</i>
        出现在每一个文字视窗的最後一列，其描述此
        视窗的相关资讯。 <i>mode line</i>
        所描述的讯息如下: --ch-Emacs: buf （major minor）
        --pos-------------- 现在则分别解释其所代表的意义。
        <ul>
            <li>rl-h
                代表缓冲区的状态（何谓缓冲区会在下一节讨论）。</li>
            <li><ul>
                    <li>-- 表示缓冲区未被修改过。</li>
                    <li>　</li>
                    <li>** 表示缓冲区已被修改过。</li>
                    <li>　</li>
                    <li>%% 表示缓冲区为 read-only
                        的缓冲区。</li>
                    <li>　</li>
                    <li>%* 表示 read-only
                        的缓冲区被修改过。</li>
                    <li>　</li>
                </ul>
            </li>
            <li>buf</li>
            <li>表示此视窗缓冲区的名称，一般即为所编辑的档案名称。</li>
            <li>major minor</li>
            <li>此缓冲区所有使用的模式（ mode）都列举在此括号内。其中
                包括一个主要模式 (major mode）和数个次要模式（
                minor mode）。 EMACS 允许一个缓冲区有数个次要模式，但只能有一个主要模式。</li>
            <li>pos</li>
            <li>表示文件在视窗显示的情形。其表示的种类如下：<ul>
                    <li>All</li>
                    <li>如果资料很少可以一「幕」了然，则会以
                        All 来表示。</li>
                    <li>Top</li>
                    <li>若资料无法一「幕」了然，但出现的位置在最前面，则以
                        Top 来表示。</li>
                    <li>无法一「幕」了然的资料，出现的位置是在最尾端，则以
                        Bot 来表示。</li>
                    <li>　</li>
                    <li>nn%</li>
                    <li>若资料出现的位置不在第前端也不在最後端，则以百分比
                        来表示资料出现的情形。</li>
                </ul>
            </li>
        </ul>
    </dd>
    <dd>介绍完了 <i>mode line</i> ，现在来谈谈 <i>echo
        area</i> 与 <i>minibuffer</i>。在 <i>frame </i>的最後一列，也就是
        <i>mode line</i> 的下一列就是 <i>echo area</i>或 <i>minibuffer</i>
        出现的地方。二者使用同一区位但所代表的意思却不相同。
        Echoing 的意思就是将键入的字元在萤幕上回应出来。
        EMACS 对於只有一个字元的指令并不会把它
        Echoing 出来，例如 `` Ctrl-e''。
        对於多个字元的指令，只要在键入指令的时候给予稍许的停顿，
        <i>echo area</i> 就会把键入的指令回应出来。等第一次的回应
        产生时，再输入的部份就不需要再给予停顿的时间，其回应会在
        键入的同时立即产生。 <i>echo area</i> 除了回应键入的指令，
        也会将指令所产生的讯息显示出来；错误讯息的显示也是利用此区域。</dd>
    <dd><i>minibuffer</i> 所使用的地方与 <i>echo area</i>
        相同。它本身也是一个视窗，是用来输入执行指令所需的引数（argument）。
        使用 <i>minibuffer</i> 的同时也会使用 <i>echo
        area</i>。 </dd>
    <dd><i>minibuffer</i> 输入引数的地方，是在 <i>echo
        area</i> 回应字串的 ``：'' 之後。因为 <i>echo
        area</i> 的回应是以 ``：'' 的出现做为结束。换言之，
        ``：''冒号之後就是 <i>minibuffer</i>
        输入引数的地方。 </dd>
    <dd>例如，要访问一个档案，键入指令 ``Ctrl-x
        Ctrl-f'' 时， <i>echo area</i> 会出现 Find file:
        ``Find file'' 就是 <i>echo area</i>
        的回应字，而此回应字串以 ``：''
        做为结束。 所以 ``：'' 之後，就是 <i>minibuffer</i>
        的地盘了， 也就是 <i>minibuffer</i> 输入引数的地方。
    </dd>
    <dd>使用 <i>minibuffer</i> 时，游标会自动移至 <i>minibuffer</i>
        所在处，当游标在 <i>minibuffer</i>
        时，就表示可以输入引数了。
        若游标因为某些原因不出现在 <i>minibuffer</i>
        的位置，此时可以 `` Ctrl-x o （other-window)使游标在视窗间移动，直到游标出现在
        minibuffer 所在的视窗为止。 若已在 <i>minibuffer</i>
        的状态， 但不想输入任何引数，此时可以
        `` Ctrl-g（keyboard-quit）) 离开 <i>minibuffer</i>。输入
        ``Ctrl-g'' 後，游标会移至其它的视窗。 </dd>
    <dd><i>minibuffer</i>
        也是一个视窗，所以可以从别的视窗
        移至此视窗； `` Ctrl-x o''
        的指令就是用来使游标在各个视窗间
        移动的。一般的 <i>minibuffer</i>
        都只有一列的高度，但有时
        一列的高度无法将资料显示完毕，此时的 <i>minibuffer</i>
        就需要 调整其大小了。至於如何将 <i>minibuffer</i>
        的视窗做调整，
        就是下一节所要讨论的重点之一了。 <hr>
        <h2><a name="4">Emacs 的缓冲区与视窗</a></h2>
        <h4>EMACS
        的缓冲区与视窗的关系密不可分，缓冲区是用来存放
        编辑文件的，但视窗却是用来显示缓冲区的文件。现在就来谈谈
        缓冲区和视窗。 缓冲区（buffer）是 EMACS
        编辑文件时，暂时存放文件的地方。
        这个地方只用来暂时存放文件，要想永久保留这些文件，必需将
        暂时存放的文件储存起来，一般是使用硬碟来安置缓冲区的文件。
        </h4>
    </dd>
    <dd>在 EMACS
        中所做的任何事情，都是先暂放於缓冲区内。
        EMACS 处理档案的方式，也是先将档案从硬碟中取出後，
        再放於缓冲区内。所以不论是删减、修改与新增文件，都是在
        缓冲区内进行，除非将缓冲区内的文件存回硬碟，否则硬碟的内容
        都不会因缓冲区内容的改变而改变。 </dd>
    <dd>文件未存回硬碟而离开 EMACS（kill EMACS），将永远消失
        。但 EMACS 有一个自动储存文件的功能，称为
        `` auto save'' 。
        每当键入一定数量的字元（通常是三百个字元），EMACS
        就会
        自动做储存的动作；经过一段停置的时间（通常是三十秒），
        EMACS 也会做自动储存的动作。 </dd>
    <dd>EMACS
        自动储存的功能并非将文件直接存回该档案
        所在的硬碟中，而是将缓冲区的文件存入一个暂存档内。
        只有以存档的指令，例如 `` Ctrl-x Ctrl-s''
        的指令，将缓冲区的 文件存回硬碟时，缓冲区内的文件才会存回硬碟中。只有当文件
        存回硬碟中，EMACS
        才会自动清除此暂存档。若缓冲区的内容
        一直未存回硬碟，此暂存档就会一直存在著，直到存回硬碟才会消失。
    </dd>
    <dd>EMACS
        如此安排暂存档有两个好处，第一个好处是可以
        确保编辑的档案资料不会流失；第二个好处是可预防机器意外关机
        或当机，档案不及存回硬碟，所造成的损失。EMACS
        命名此暂存档 的方式，是以缓冲区所使用的档名为依据。在档名的前後各加上一个
        ``#''
        ，就是暂存档的名称。举例说明，若所编辑的档名为
        ``emacs.doc'' ， 其产生的暂存档即为：
        #emacs.doc# 若所编辑的档案未存回硬碟时，
        EMACS 会自动产生一个暂存档。 下次编辑此档时，
        EMACS 允予使用者从暂存档中将流失的资料回复。
        例如编辑的档案为 ``emacs.doc''，在离开 EMACS
        时未存回硬碟 ， EMACS 会自动产生一个
        ``#emacs.doc#'' 的自动储存档。当重新启动
        EMACS 且编辑 ``emacs.doc'' 档时， EMACS 会提示使用者此档案
        已被更改过但未给予适当的储存。此时，使用者可自行决定是否
        要从自动储存的档案中（#emacs.doc#）将
        ``emacs.doc'' 档中 未被储存的资料找回。 </dd>
    <dd>如何从自动储存档中将资料找回呢？想要从自动储存的档案中，
        恢复原始档案中流失的资料，可以使用 ``
        Meta-x recovery-file''
        的指令。若存放於硬碟中的档案，有相对应的自动储存档时，
        可经由如下的步骤将资料找回： <ol>
            <li>键入 ``Ctrl-x Ctrl-f RET''</li>
            <li>Find file: ~/ filename </li>
            <li>在 Find file:
                处输入所欲编辑的档案後後， <i>echo
                area</i> </li>
            <li>会出现如下的讯息： Auto save file is
                newer: consider M-x recovery-file</li>
            <li>键入 ``Meta-x recovery-file RET'' </li>
            <li>此时 echo area
                会自动出现相对应的自动储存的档案名称，
                若愿意执行恢复的动作，只要直接按下
                RET 即可。否则， 以 ``Ctrl-g''
                指令，放弃此命令的执行。 </li>
        </ol>
    </dd>
    <dd>除了暂存档外， EMACS
        对於每一个编辑的档案， 都会在编辑前做一份备份，以防止在编辑的过程中因一时的疏忽
        而将档案毁损。备份档的设计是，当档案被存回硬碟後，备份档
        也不会因此而消失。 </dd>
    <dd>EMACS
        命名备份档的方式，是在所要编辑的档名之後加上
        ``~'' 。例如， ``emacs.doc'' 的备份档就为
        ``emacs.doc~''。 </dd>
    <dd>以上的设定是可以改变，因为它们都是变数。下面
        列出相关的变数，使用者可自行决定其所需。
        <ul>
            <li>auto-save-visited-file-name</li>
            <li>设定自动储存档案的种类。可以设为暂存档也可设为正在
                使用的原档案。 </li>
            <li>delete-auto-save-file</li>
            <li>设定档案被存回硬碟後，自动储存的暂存档是否会自动删除。
            </li>
            <li>auto-save-interval</li>
            <li>设定自动储存时的字元数。 </li>
            <li>auto-save-timeout</li>
            <li>设定自动储存时的时间。 </li>
        </ul>
        <p>想知道如何设定变数吗？在 EMACS
        中任何设定变数的方法都是以 `` Meta-x
        set-variable（或 ESC-x set-variable）''的指令来完成
        变数的设定。变数值的设定，可以只设定真假值或设定数值或是
        设定字串。 </p>
    </dd>
    <dd>若只是设定变数的肯定或否定值时， EMACS
        有一个遵循 的规则。EMACS 中以任何
        ``non-nil'' 的值来代表肯定，习惯上是以 ``t''
        来表示肯定；而以 ``nil'' 来代表否定。 </dd>
    <dd>在设定新的变数值之前，若想知道目前变数的值，
        EMACS 可以 `` Ctrl-h v''(describe-variable)
        来查阅变数的值。 现在就举设定
        ``auto-save-visited-file-name''，<p>``和
        auto-save-interval''
        二个变数来说明变数设定的方法。 </p>
        <ol>
            <li>以 `` Ctrl-h v'' 查阅
                auto-save-visited-file-name 的变数。</li>
            <li>以 `` Meta-x set-variable'' 来设定变数 。</li>
            <li>再以 `` Ctrl-h v'' 来查阅所设定的
                auto-save-visited-file-name 变数。</li>
        </ol>
        <p>现在来看看设定 auto-save-visited-file-name
        这一个变数的实际过程： </p>
        <ol>
            <li>键 ``Ctrl-h v RET''</li>
            <li><ol>
                    <li>echo area 处会出现 Describe variable：</li>
                    <li>在 Describe variable: 後键入
                        auto-save-visited-file-name</li>
                    <li>萤幕上会另开一个视窗，显示如下的讯息：
                    </li>
                    <li>auto-save-visited-file-name's value is
                        nil Documentation: *Non-nil says
                        auto-save a buffer in the file it is
                        visiting, when <p>practical. Normally
                        auto-save files are written under other
                        names.</p>
                    </li>
                </ol>
            </li>
            <li>键入 ``Meta-x set-variable''</li>
            <li><ol>
                    <li>echo area 处会出现 Set varaible:</li>
                    <li>　</li>
                    <li>在 Set variable: 後键入
                        auto-save-visited-file-name RET</li>
                    <li>　</li>
                    <li>echo area 处会出现 Set
                        auto-save-visisted-file-name to value：</li>
                    <li>　</li>
                    <li>此时可以利用在 ``：'' 之後的 <i>minibuffer</i>，输入变数
                        的值。此变数的值不是肯定就是否定的。目前的值是
                        nil，要改 其值为肯定的可以输入
                        t。</li>
                    <li>　</li>
                </ol>
            </li>
            <li>再以 ``Ctrl-h v''
                来检视变数设定的情形。</li>
        </ol>
        <p>上一个例子是设定肯定与否定值的例子，现在来看看设定变数值
        为数字的例子。 auto-save-interval
        实际执行的过程： </p>
        <ol>
            <li>键入 ``Ctrl-h v RET''</li>
            <li><ol>
                    <li>echo area 处会出现 Describe variable：</li>
                    <li>在 Describe variable: 後键入
                        auto-save-interval</li>
                    <li>萤幕上会另开一个视窗，显示如下的讯息：</li>
                    <li>auto-save-interval's value is 300
                        Documentation:<p>*Number of keyboard
                        input characters between auto-saves.</p>
                        <p>Zero means disable autosaving due to
                        number of characters typed.</p>
                    </li>
                </ol>
            </li>
            <li>键入 ``Meta-x set-variable''</li>
            <li><ol>
                    <li>echo area 处，会出现 Set varaible :</li>
                    <li>在 Set variable: 後键入
                        auto-save-interval RET </li>
                    <li>echo area 处会出现 Set
                        auto-save-interval to value：</li>
                    <li>此时可以利用 ``：'' 之後的 <i>minibuffer</i>，输入变数
                        的值。此变数的值为数字。目前的值是
                        300，使用者可根据需要
                        输入适当的数字。 </li>
                </ol>
            </li>
            <li>再以 ``Ctrl-h v''
                来检视变数设定的情形。</li>
        </ol>
    </dd>
    <dd>在 EMACS
        执行过程中所设定的变数值，只对目前所执行的
        EMACS 有用，一旦离开此 EMACS，所有的设定就恢复成原来的
        预设值。要想永久保留此设定的变数值，就必需将所设定的变数值
        储存在档名为 ``.emacs'' (.emacs 档为 EMACS
        的启始档，进入 EMACS
        时会先执行此档内的指令， EMACS
        的设定也是根处此档 而来的的档案中。因为启动
        EMACS 时， EMACS 会先执行 .emacs
        档，所有存於此档案的变数会被重新设定一次。
    </dd>
    <dd>在 .emacs 档中设定变数
        ``auto-save-visited-file-name'' 与
        ``auto-save-interval'' 的方法如下所示： (setq
        auto-save-visited-file-name t) (setq auto-save-interval
        350) 前已述及 EMACS
        可以容许多个缓冲区的同时存在，既然如此，
        自然有其处理每个缓冲区的方法。现在就来看看
        EMACS 如何 处理缓冲区。 <ul>
            <li>Ctrl-x b buffer RET （switch-to-buffer）
                此指令用来选择不同的缓冲区，其预选的缓冲区是目前所使用
                的缓冲区之外，最近被使用过的缓冲区。此指令可以使用
                completion 。 使用此指令， echo area
                会出现如下的讯息： Switch to buffer:
                (default filename) 若所要选择的缓冲区不是系统所预设的，可以利用
                <i>minibuffer</i> 将所要选择的缓冲区名称键入。
            </li>
            <li>Ctrl-x k buffername RET （kill-buffer）
                此指令是用来删除 <i>minibuffer</i>
                所显示的缓冲区。若只键入 RET
                ，则删除目前的缓冲区，否则，删除所输入的缓冲区名称。
                同样的，此指令可以使用 completion。 </li>
            <li>Ctrl-x Ctrl-b （list-buffer） 将目前 EMACS
                所使用过的缓冲区显示出来。
                以下的就是执行 ``Ctrl-x Ctrl-b''
                时，视窗所显示的资料： <table
                border="0">
                    <tr>
                        <th align="left">MR Buffer</th>
                        <th align="left">Size Mode</th>
                        <th align="left">File</th>
                    </tr>
                    <tr>
                        <th align="left">-- ------ </th>
                        <th align="left">----</th>
                        <th align="left">----</th>
                        <th align="left">----</th>
                    </tr>
                    <tr>
                        <th align="left">.* chap4.tex</th>
                        <th align="left">17460</th>
                        <th align="left">LaTeX </th>
                        <th align="left">/home/usr/hsko/work/chap4.tex</th>
                    </tr>
                    <tr>
                        <th align="left">*% RMAIL</th>
                        <th align="left">8788</th>
                        <th align="left">RMAIL </th>
                        <th align="left">/home/usr/hsko/RMAIL</th>
                    </tr>
                    <tr>
                        <th align="left">* *Buffer List* 241</th>
                        <th align="left">Buffer Menu</th>
                    </tr>
                    <tr>
                        <th align="left">*scratch*</th>
                        <th align="left">0</th>
                        <th align="left">lisp Interaction</th>
                    </tr>
                    <tr>
                        <th align="left">diary</th>
                        <th align="left">928</th>
                        <th align="left">Fundamental </th>
                        <th align="left">/home/usr/hsko/diary</th>
                    </tr>
                    <tr>
                        <th align="left">% *man ls*</th>
                        <th align="left">15420</th>
                        <th align="left">Man</th>
                    </tr>
                    <tr>
                        <th align="left">*Help*</th>
                        <th align="left">64</th>
                        <th align="left">Fundamental </th>
                    </tr>
                </table>
                <p>以上资料的每一栏位各有其所代表的意思，详述如下：
                </p>
                <ul>
                    <li>栏位 MR，标记缓冲区的状态，其可能的状态如下所示：
                        <ul>
                            <li>``*'' </li>
                            <li>表示此缓冲区被修改过。</li>
                            <li>``.*''</li>
                            <li>``.''
                                表示此缓冲区为目前被选择的缓冲区，
                                ``.*''表示此选用
                                的缓冲区被修改过。</li>
                            <li>``%''</li>
                            <li>``%'' 表示此缓冲区为
                                read-only 的缓冲区。</li>
                            <li>``%*''</li>
                            <li>表示此 read-only
                                的缓冲区被修改过。</li>
                        </ul>
                    </li>
                    <li>栏位 Buffer，显示所使用的缓冲区名称。</li>
                    <li><ul>
                            <li>Buffer
                                中的资料若为档案名称时，则表示缓冲区所放置
                                的资料为一个档案。</li>
                            <li>　</li>
                            <li>若 Buffer
                                中的资料前後加上了 ``*''，则表示此缓冲
                                区不是任何被访问的档案。</li>
                            <li>　</li>
                        </ul>
                    </li>
                    <li>栏位 Size，显示缓冲区的大小。</li>
                    <li>　</li>
                    <li>栏位 Mode，显示缓冲区所使用的主要模式。</li>
                    <li>　</li>
                    <li>栏位 File，表示所访问档案的绝对名称。若缓冲区的资料
                        不是来自访问的档案，亦即栏位
                        Buffer 的名字前後加上 ``*'' 时，
                        则以空白表示。</li>
                    <li>　</li>
                </ul>
            </li>
            <li>Meta-x buffer-menu </li>
            <li>此指令好似 Dired\indexdired
                的功能，应用在缓冲区上。
                此指令可对列出来的缓冲区各别做运作。其运作内容包括，储存
                缓冲区、删除缓冲区、显示缓冲区以及编辑缓冲区等等。其实
                运作於 `` Meta-x buffer-menu'' 的指令同样也可用在
                `` Ctrl-x list-buffer'' 上， 只是使用 ``
                Meta-x buffer-menu'' 指令时， echo area
                处会显示出 可运用的选项。其可运用的选项内容如下所示：
                Command: d, s, x, u; f, o, 1, 2, m, v; ~, %; q to
                quit; ? for help.
                现举较常使用的选项说明，至於其余的选项，使用者可键入
                ``?'' ，来使用其所提供的线上述助。 <ul>
                    <li>d</li>
                    <li>标示所欲删除的缓冲区。 在 MR
                        栏位的最前方会出现 D。此时并未真正删除缓冲区，
                        只是将要删除的缓冲区做上标记，直到下达执行标记的命令时，
                        才会真正将标示 D
                        的缓冲区删除。此执行的指令为
                        `` x''。 </li>
                    <li>s</li>
                    <li>标示所欲储存的缓冲区。 在 MR
                        栏位处标示上 S 。此时并未真正做储存的动作，只是
                        在要储存的缓冲区做上标记，直到下达执行标记的命令时，
                        才会真正将标示 S
                        的缓冲区存档。 </li>
                    <li>x</li>
                    <li>对做好标记的缓冲区，下达执行的命令。也就是对标示有
                        D 与 S 的缓冲区，做执行的动作。
                    </li>
                    <li>u</li>
                    <li>将设好的标记取消。 </li>
                    <li>f</li>
                    <li>选择目前游标所在处的缓冲区。此时的视窗会将此缓冲区的内容
                        显示出来、 </li>
                </ul>
            </li>
        </ul>
        <p>谈完了 EMACS
        的缓冲区，现在来谈谈与其关系密切的视窗。
        前已略述，进入 text-only 的 EMACS，即进入一个
        frame。 一个 <i>frame </i>由数个视窗组成，每一个视窗显示一个
        EMACS 的缓冲区，且一次只显示一个缓冲区的内容。
        </p>
    </dd>
    <dd>EMACS
        在任何时候，总有一个视窗为选择的视窗
        （ selected window）。此视窗所显示的缓冲区，则称为目前的
        缓冲区（ current buffer）.point（或称为游标）
        所在的视窗，就是 EMACS 的选择视窗。EMACS
        是透过游标来示 point 所在的位置。
        所以说，若想要知道目前的选择视窗，观察游标所在的位置就可知道。
    </dd>
    <dd>至於什麽是 point 呢？ point
        就是用来标示目前 所使用的视窗或缓冲区所在的位置。EMACS
        的每一个视窗， 各有其所专属的点位置（
        point location）.每一个缓冲区
        也有属於它自已的点位置。每一个缓冲区或视窗
        point 的位置， 并不会随著视窗或缓冲区的改变而变动。换言之，point
        的位置会 随时被记录下来，当再次访问其它的视窗或缓冲区时，游标仍会
        回到离开前的位置。所以，任何移动 point
        的指令，只会对所选择 的视窗产生影响，对於其它视窗的
        point 是不会有任何影响的。 EMACS 下的每个视窗除了有各自的
        point 外，也各自有其相对应的 <i>mode line</i>。
    </dd>
    <dd>EMACS
        视窗的大小是容许重新调整的。除了大小是
        可以调整的，一个视窗也可以再分成两个视窗。其分割的方法，
        可以做水平或垂直的化分。视窗的操作，除了分割视窗之外，
        也可以使游标在不同的视窗间移动；当然，将不需要的视窗删除
        也是基本的功能。现在就来看看与视窗相关的指令。
        <ul>
            <li>Ctrl-x 2（split-window-vertically)</li>
            <li>将一个视窗分成上下两个视窗。此时化分出来的两个视窗，分享
                著化分前视窗的缓冲区。换言之，此时两个视窗的缓冲区内容是
                一样的。因为共享著同一个缓冲区，所以改变其中一个视窗缓冲区
                的内容，也会改变另一个视窗缓冲区的内容。分割成两个视窗的
                好处之一是，可以编辑一个缓冲区，将另一个缓冲区作为参考的依据。
                <ul>
                    <li>Ctrl-x ^ （enlarge-window）
                        将目前游标所在的视窗拉长一列。此指令，只有在
                        <i>frame </i>存在一个以上的视窗时才有效果。若只有一个视窗，此视窗就
                        占据了整个 <i>frame</i>，此时自然就无多余的空间可以放大了。
                    </li>
                    <li>Ctrl-u n Ctrl-x ^ （enlarge-window nn）
                        与 Ctrl-x ^ 指令相似。不同之处在於，此指令可以将目前游标
                        所在的视窗拉长 n 列以上。</li>
                </ul>
            </li>
            <li>Ctrl-x 3（split-window-horizontally）</li>
            <li>将视窗分成左右两个视窗。此时的两个视窗依然拥有相同的
                缓冲区，所以，改变一个视窗缓冲区的内容，同时也会改变
                另一个视窗缓冲区的内容。 <ul>
                    <li>Ctrl-x （enlarge-window-horizontally）</li>
                    <li>将目前游标所在的视窗拉宽一行。对
                        <i>frame </i>存有一个
                        以上的视窗才有效。若只有一个视窗，此视窗已经占据整个
                        <i>frame </i>了，即使想放大，恐怕也爱莫能助了。
                    </li>
                    <li>Ctrl-u n Ctrl-x （enlarge-window-horizontally
                        nn ） 与 Ctrl-u
                        指令相似。此指令可以将目前游标所在的视窗
                        拉宽n 行。 </li>
                </ul>
            </li>
        </ul>
        <dir>
            <li>Using Other Windows and Deleting Windows</li>
            <li><ul>
                    <li>Ctrl-x o（other-window）</li>
                    <li>此指令是用来选择所欲使用的视窗。注意，此
                        `` o'' 是英文字的 `` o''，而非数字的
                        ``0''。 </li>
                    <li>Ctrl-x 0（delete-window）</li>
                    <li>将目前游标所在的视窗删除。提醒大家注意，此
                        `` 0'' 是 阿拉伯数字的 `` 0''。 </li>
                    <li>Ctrl-x 1（delete-other-window)</li>
                    <li>保留目前游标所在的视窗，其余的视窗全部删除。
                    </li>
                </ul>
            </li>
        </dir>
    </dd>
    <dd>视窗的大小是有限的，但缓冲区的内容却经常超过视窗
        所能显示的范围。接下来就是要告诉各位，如何在有限的空间中，
        以窥缓冲区的全貌。 想要在视窗的局限下，洞悉缓冲区的全貌，其最基本动作就是
        卷动萤幕。所谓萤幕的卷动，就是萤幕上下左右的移动。除了
        卷动萤幕之外，还需考虑萤幕的清除。在那些情形之下要清除
        萤幕呢？例如，远方送来的 message，
        在萤幕的显示久久不退； 系统送来的讯息也在萤幕上不会消失。这些情况的发生，都值得
        将萤幕做清除且重新显示的动作。以下就来看看这些相关的指令。
        <ul>
            <li>Ctrl-l（recenter）（清除萤幕）</li>
            <li>清除萤幕且重新显示萤幕。 </li>
            <li>使萤幕上下卷动</li>
            <li><ul>
                    <li>Ctrl-v（scroll-up）（向上卷动萤幕一列）</li>
                    <li>向上卷动萤幕，且将目前萤幕的最後二列做为卷动後萤幕的
                        前二列。 <i>point</i>
                        出现在萤幕的第一列。 </li>
                    <li>Ctrl-u n Ctrl-v （向上卷动萤幕 n
                        列）</li>
                    <li>萤幕向上卷动 n 列。
                        若指定卷动的列数 n ，不超过
                        point 在此萤幕上所在
                        的列数，卷动後的 point
                        仍会留在原处不动，否则 <i>point</i>
                        移至萤幕的第一列。 </li>
                    <li>Meta-v（scroll-down）（向下卷动萤幕一列）</li>
                    <li>向下卷动萤幕，
                        且将目前萤幕的前二列做为卷动後萤幕的後二列，
                        point 出现在萤幕的最後一列。 </li>
                    <li>Ctrl-u n Ctrl-v（向下卷动萤幕 n
                        列）</li>
                    <li>萤幕向下卷动 n 列。
                        若向下卷动的列数 n，不超过
                        point 在此萤幕所在位置以下
                        的列数， 卷动後的 point
                        仍会留在原处不动，否则 <i>point</i>
                        移至萤幕的最後一列。 </li>
                    <li>Meta &lt; （beginning-of-buffer）（萤幕卷至缓冲区的最前端）</li>
                    <li>(beginning-of-buffer)将萤幕卷至缓冲区的最前端，
                        point 也移至第一列。 </li>
                    <li>Meta &gt;（end-of-buffer）（萤幕卷至缓冲区的最尾端）
                        将萤幕卷至缓冲区的最尾端， <i>point
                        </i>也移至最後一列。 </li>
                    <li>Ctrl-ESC-v（scroll-other-window）</li>
                    <li>前面六个卷动萤幕的指令，都是针对游标所在位置的视窗而言，
                        若要卷动其它的视窗，则必需使用
                        `` Ctrl-ESC-v''。 `` Ctrl-ESC-v''
                        指令是用来卷动游标所在位置下一个视窗的萤幕。
                        所以，如果开启了两个视窗，可以使用此指令来参考非游标所在
                        位置的缓冲区资料。此指令方便之处在於，可以省略移动游标
                        的步骤，就可以卷动其它的视窗。
                        如果今开启了 A 与 B
                        二个视窗，游标在视窗 A
                        处，以 `` Ctrl-ESC-v''
                        可以卷动视窗 B。如果开启二个以上的视窗，
                        `` Ctrl-ESC-v''
                        指令所卷动的视窗，就必需看那一个视窗最
                        接近游标所在的视窗了。 </li>
                </ul>
            </li>
            <li>使萤幕左右卷动</li>
            <li><ul>
                    <li>Ctrl-x &lt;（scroll-left)</li>
                    <li>萤幕向左卷动。</li>
                    <li>Ctrl-x &gt;（scroll-right）</li>
                    <li>萤幕向右卷动。</li>
                </ul>
            </li>
            <li>上下移动游标</li>
            <li><ul>
                    <li>Ctrl-p 或 ↑（previous-line）</li>
                    <li>↑Ctrl-p
                        可以使游标向上移动一列。若有设定功能键，则可以用
                        来移动游标。</li>
                    <li>Ctrl-u n Ctrl-p</li>
                    <li>使游标向上移动 n 列。</li>
                    <li>Ctrl-n 或 ↓next-line） Ctrl-n
                        可以使游标向下移动一列。若有设定功能键，则可以用
                        ↓ 来移动游标。 </li>
                    <li>Ctrl-u n Ctrl-n</li>
                    <li>使游标向下移动 n 列。 </li>
                </ul>
            </li>
        </ul>
        <hr>
        <p><a href="index.html">回上页</a> </p>
    </dd>
</dl>
</body>
</html>
